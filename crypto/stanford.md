## 数学记号

$$
\begin{aligned}
&\#{} \ \ 集合的元素个数
\\
&|m| \ \ m的长度
\\
&\{0,1\}^n\ \ 由0|1组成的长度为n的串
\end{aligned}
$$

## 概率

### 事件

对于集合U的子集A，其中P(U) = 1
$$
P(A) = \sum_{x \in A}P(x) \in [0,1]
$$
则A称为一个事件

### 离散分布

随机变量X = {x1, x2, x3, ... , xn}

符合 P(x1) = p1  P(x2) = p2 ...

称 (X, P)为离散分布

#### 均匀分布

是离散分布的一种，满足对于集合U
$$
U = \{0, 1\}^n
\\
对于 a \in U: P(r=a) = \frac{1}{|U|}
$$

### 独立性

对于事件A和B为独立事件当A和B的概率满足下式
$$
P(A \cap B) = P(A) * P(B)
$$

## 异或

异或的一个重要性质是，对于一个**任意分布的变量A**和一个**均匀分布的变量B**，结果**C是均匀分布的**
$$
\begin{aligned}
& 假设随机变量A为任意分布，A = \{0, 1\}^n。随机变量B为均匀分布，B = \{0,1\}^n
\\
& P(An=1) = p_1
\\
& P(Bn=1) = 0.5
\end{aligned}
$$
那么对于Cn
$$
\begin{aligned}
P(Cn=1) &= P( ((An=1)\cap(Bn=0)) \cup ((An=0) \cap (Bn=1)) )
\\
& = p_1 * 0.5 + (1-p_1) * 0.5
\\
& = 0.5
\end{aligned}
$$
同样
$$
\begin{aligned}
P(Cn=0) &= P( ((An=0)\cap(Bn=0)) \cup ((An=1) \cap (Bn=1)) )
\\
& = (1-p_1) * 0.5 + p_1 * 0.5
\\
& = 0.5
\end{aligned}
$$

## One TIme Pad

### 方法

#### 密钥空间

$$
K = \{0, 1\}^n
$$

#### 明文空间

$$
M = \{0, 1\}^n
$$

#### 密文空间

$$
C = \{0, 1\}^n
$$

#### 加密

$$
C = K \oplus M
$$

#### 解密

$$
M = K \oplus C
$$

#### 正确性

$$
\begin{aligned}
D(K, E(K,M)) &= D(K, K \oplus M)
\\
&= K \oplus K \oplus M
\\
&= M
\end{aligned}
$$

### 安全性

#### 完美安全性

对于(K,M,C)对的加解密算法(E,D)具有完美安全性，当满足下式
$$
\forall m_0, m_1 \in M,\ k \in K,\ c \in C \ \ \ (|m_0| = \ |m1|)
\\
P[ E(k,m_0) = c ] = P[E(k,m_1)=c]
$$
m0与m1通过密钥k加密后得到c的概率是相同的，即若知道密文c，无法从概率上获知其由m0加密而来还是m1，因为概率完全相同

然后看P[E(k,m) = c]的概率
$$
\forall m,c:\ \ P[E(k,m)=c] \ = \ \frac{\#\{k \in K | E(k,m)=c\}}{\#{K}}
$$
即，**能将m映射到c的密钥数除以密钥总数**

所以，根据上式，若具有完美安全性，则对于每个m、c，因为要求P[E(k,m)=c]相等，而因为密钥空间大小一定，因此$\#\{k \in K | E(k,m)=c\} = 常数$

**上述过程也证明了**

##### OTP具有完美安全性的证明

因为对于每一个m，c
$$
c = E(k,m)
$$
则
$$
k = m \oplus c
$$
因此
$$
\#\{k \in K | E(k,m)=c\} = 1
$$

##### 局限性

由上述过程可知，要满足完美安全性，有
$$
\#\{k \in K | E(k,m)=c\} = const
$$
这里表示能把m映射为c的密钥总数，因此肯定是自然数。因此要满足完美安全性，有
$$
|K| \geq |M|
$$
即密钥空间大于等于明文空间，因此密钥长度大于明文长度

## 流密码

### 伪随机数生成器（PRG）

#### 定义

以一个随机数种子作为输入，将随机数种子空间的s位种子映射到n位字符串，其中n >> s
$$
G:  \{0, 1\}^s \rightarrow \{0, 1\}^n
$$

#### 性质

##### 不可预测性

###### 定义

一个算法G是可预测的，当满足下面定义
$$
\exist \  1 \leq i \leq n-1, 对于伪随机算法G，有一个算法A
\\
P[ A(G(k)) \big|_{1,...,i} = G(k) \big|_{i+1} ] \geq \frac{1}{2} + \varepsilon
$$
即，使用A可以通过G的前i个输出预测第i+1个输出，并且被预测的可能性大于一个**不可忽略的量$\varepsilon$**

###### 注：不可忽略

实用的定义：

* $\varepsilon \geq \frac{1}{2^{30}}$   不可忽略
* $\epsilon \leq \frac{1}{2^{80}}$  可忽略

形式化定义

$函数 \epsilon: Z^{\geq0} \rightarrow R^{\geq0}$

* 不可忽略 $\exist d: \epsilon(\lambda) \geq \frac{1}{\lambda^d}$
* 可忽略  $\forall d, \lambda \geq \lambda_d: \varepsilon(\lambda) \leq \frac{1}{\lambda^d}$

即若存在$\lambda_d$，使得当$\lambda \geq \lambda_d$时，对于每个d都有$\epsilon(\lambda)都小于\frac{1}{\lambda^d}$

这里的定义有点类似于无穷小的定义，其实也应是等价的，因为可忽略即说明误差趋于无穷小

**不可忽略性判断的几个例子**

* $\epsilon(\lambda) = \frac{1}{2^\lambda}  因为显然2^\lambda在某点后增长速度大于\lambda^d，即 2^\lambda \geq \lambda^d，即\lambda \geq d\ log_2\lambda$

  由函数性质可知无论d取何值，必有$\lambda$使表达式成立，所以可忽略

* $\epsilon(\lambda) = \frac{1}{\lambda^{1000}}  显然没有一个确定的\lambda_d能满足上式，因为只要d>1000。因此不可忽略$


#### 统计测试

统计测试是对于一个函数A(x)，其输出为0 1，作用于二进制串$\{0,1\}^n$

##### 例子

下面举出几种常见的统计测试的例子

* $A(x) = 1 \ 若\ | \#0(x) - \#1(x) | \leq 10*\sqrt{n}$，即二进制串中1的数量与0的数量之差
* $A(x) = 1 \  若\  |\#00(x)-\frac{1}{4}| \leq 10*\sqrt{n}$

##### Advantage

对于每一个统计测试A和伪随机序列G，真随机序列x，有
$$
Adv_{PRG}[A,G] = | \ P[A(G(k)) = 1]- P[A(x)=1] \ |
$$
即对伪随机序列进行测试A与对真随机序列进行测试A时，A输出1的概率之差。显然如果这个差越大，PRG与真随机序列的差别就越大

#### PRG安全性

$若对每一个有效的统计测试，Adv_{PRG}[A,G]的值是可以忽略的，则称该PRG安全$

即，所有有效的统计测试都无法区分真随机序列与伪随机序列

**但没有一种方法能严格证明一个伪随机序列满足所有的统计测试A，即没有办法严格证明PRG是安全的（P=NP问题）**

##### PRG安全性与可预测性

$\forall i \in \{0,...,n-1\}, 若G[i]无法预测，则G是安全的PRG$

##### 计算不可区分

对于P1和P2两个序列，有

$\forall A,\  | \ P[A(x)=1] - P[A(y)=1] \ | < neg.\ ，则称P1和P2不可区分。其中x \in P1 ，y \in P2，记为P1 \approx P2，其中neg.代表可忽略的量$

#### PRG实例

##### LFSR 线性移位反馈寄存器

原理很简单，非常适合硬件实现

```
xor--> | b0 | b1 | b2 | b3 | b4 | b5 | b6 | b7 | ----->  output
|_______________________|_________|_________|
```

即

```
output <= b7
b[0:7] <= {b[3]^b[5]^b[7], b[0:6]}
```

##### 线性同余

```
srand(seed):
	r[0] = seed

rand():
	r[i] = (a * r[i-1] + b) mod p
	return r[i++] & 0xfff			//输出r[i]的其中几位
```

glibc random

```
rand():
	r[i] = (r[i-3] + r[i-31]) mod 2^32
	return r[i] >> 1
```

### Two Time Pad攻击

对于OTP，一个密钥只能用于一次加密，因为如果加密两次信息，则是不安全的
$$
C1 \leftarrow m1 \oplus PRG(k)
\\
C2 \leftarrow m2 \oplus PRG(k)
$$
若截获C1，C2，则
$$
\begin{aligned}
C1 \oplus C2 &= m1 \oplus PRG(k) \oplus m2 \oplus PRG(k)
\\
&= m1 \oplus m2
\end{aligned}
$$
此时可以针对明文信息进行统计攻击（如若明文用的是ASCII则很容易攻击）

#### 历史上的TTP攻击

##### Project Venona

##### MS PPTP协议的漏洞

```
client        <--->     server
m1||m2||m3...        s1||s2||s3...

[m1||m2||m3...] ^ PRG(k)
			[s1||s2||s3...]^PRG(k)
```

加密方法为 客户端[m1||m2||m3...] ^ PRG(k)， 服务端[s1||s2||s3...]^PRG(k)。这里使用的种子k是相同的，因此导致了TTP问题

##### 802.11b WEP

```
client             server
 __________
|m | CRC(m)|
|PRG(IV||k)|
------------
     |
 __________
|IV | c1   |  ---->
 ----------
```

即这里用到的PRG生成器为IV和一个通用的k生成，其中**k是长期使用的，IV为24位**

**IV一般是数据包的计数值**，因此当数据包发送2^24时，IV会重新使用相同的值，即**每隔2^24 WEP数据包总会用相同的密钥加密**

##### 对于硬盘加密情况的TTP问题

若用户有硬盘加密，且一般来说每次加密使用的密钥不变，那么若用户使用流密码加密硬盘文件时，若有一个文件仅有一点微小的改动，首先攻击者**很容易找出改动的位置**，因为流密码按位加密。其次可以通过对比信息来还原明文，进而还原部分密钥

#### 总结

##### 网络传输

对于网络传输，每个会话应分配不同的密钥

##### 硬盘加密

硬盘加密不应该用流密码

### 完整性攻击

OTP无法保证消息的完整性，即消息内容是**可修改的**，如下

```
E(k,m) = m^k ---->  m^k^p  ----> D(k,m) = m^k^p ^k = m^p
因此若攻击者知道明文m内容，并希望将m改为n，则令p = m^n，则有
D(k,m) = m^k^m^n ^k = n
```

上面可以看出，若攻击者**知道明文m，则可以将其篡改为明文n**

### 语义安全

假设有实验 EXP(b)，b=0或b=1，有如下定义

```
挑战者                           攻击者A
随机密钥k <--m0 m1, |m0|=|m1|---
         ---E(k,m0)或E(k,m1)-->
```

即，攻击者A发送密文m0和m1，挑战者选取随机密钥，并根据b的值返回E(k,m0)（当b=0）或E(k,m1)（当b=1）。攻击者A判断返回值是m0的加密值还是m1的，并作为EXP(b)实验的输出

定义事件W(b) = [EXP(b)=1]，即W0事件为挑战者返回给攻击者A的数据是E(k,m0)时A认为返回值是E(k,m1)

此时可以定义攻击者A对加密系统E的优势
$$
Adv_{ss}[A,E] = | P[W_0] - P[W_1] |
$$
**意义如下**：攻击者A发送m0和m1两个密文长度相同的密文，返回结果是其中一个的加密，攻击者通过猜测返回值是m0还是m1的加密并把猜测值作为EXP(b)的输出。若W1和W0发生概率相同，则优势为0，说明A无法区分m0和m1的加密。

#### 例子

如攻击者可以通过密文得到明文的LSB，则设计如下实验

```
Challenger                            攻击者A
 k <- K      <--m0, LSB(m0) = 0--
                m1, LSB(m1) = 1
             --- c = E(k,mb) --->     LSB(mb) ----> output
```

该实验最后的输出值，即A对b的判断值其实是函数LSB(mb)的结果，因此若执行EXP(0)，输出LSB(m0) = 0

EXP(0) = LSB(m0) = 0 ，W0 = [EXP(0) = 1] = 0，EXP(1) = LSB(m1) = 1，W1 = [EXP(1)=1] = 1，均为恒等。因此

adv = | P[W0] - P[W1] | = | 0-1 | = 1。这说明该加密系统被破解

### 流密码语义安全性

#### 定理

若PRG $G:K \rightarrow \{0,1\}^n$ 是一个安全的PRG（即G的输出与真随机数对于攻击者来说优势为0），则使用G作为PRG的流密码E为语义安全的，且
$$
\forall 流密码攻击者A， \exist 一个PRG攻击者B，有
\\
Adv_{SS}[A,E] \leq 2 * Adv_{PRG}[B,G]
$$
**简单来说**，该定理说明**若流密码使用的PRG是语义安全的，则流密码必是语义安全的**

##### 证明

按照语义安全证明过程，假设这里的加密系统除了返回流密码$G(k) \oplus m_b$，还可能返回OTP，即真随机数r的异或结果$r \oplus m_b$

定义事件

* $W_b = [使用流密码加密时，攻击者A认为返回的是m_b加密值]$
* $R_b = [使用OTP加密时，攻击者A认为返回的是m_b加密值]$

**简单来说**，W代表使用流密码加密时攻击者A对于被加密的消息是m1还是m0的判断，R代表使用OTP加密时的判断

下面要讨论P(Wb)和P(Rb)的关系：

定义一个统计测试B，B(x) = 1 若x^m0为随机值

则B对G的优势为：
$$
Adv_{PRG}[B,G] = | P[B(r)=1] - P[B(G(k))=1] |
$$
与上面的假设结合，发现前一项即对m0^r做随机性测试，所以为$R_0$的概率，后一项为对m0^G(k)做随机性测试，所以也为$W_0$的概率，即
$$
Adv_{PRG}[B,G] = | P[R_0] - P[W_0] |
$$
而因为对于R，有
$$
Adv_{SS}(A,OTP) = |P(R_0) - P[R_1]| = 0
$$
所以
$$
\begin{aligned}
Adv_{SS}[A,E] &= \  \big| \ P[W_0] - P[W_1] \ \big|
\\
&= \ \big| \ P[W_1] - P[R_0] + P[R_0] - P[W_0] \ \big|
\\
& \leq \ \big| P[W_1] - P[R_0] \big| + \big| P[R_0] - P[W_0] \big|
\\
&= 2 * Adv_{PRG}[B,G]
\end{aligned}
$$
**因此，只要PRG的Adv是可忽略的，流密码的Adv也是可忽略的**

### 几个常见流密码

#### RC4

具体加密方法见密码编码学

##### 弱点

* 在生成的前256位中，第2位是0的概率为2/256（本应为1/256）
* 统计特征上，序列00概率为1/256^2 + 1/256^3（本应为1/256^2）
* 当时用相近密钥时的攻击

#### CSS

用于DVD的硬件加密，PRG使用LFSR

##### 原理

密钥 5bytes

```
初始化：
1 || 2byte key  -> 17b LFSR
1 || 3byte key  -> 25b LFSR

_______________
|______17b_____| ----8----|
_______________         | a+b mod 256| ----8----> c
|______25b_____| ----8----|
注：这里的a+b分别是上下两个LFSR的输出，并且考虑前一块的进位
```

##### 破解

因为DVD使用MPEG文件头，假设前n字节文件头m[0:n-1]已知，则

```
PRG[0:n-1] = m[0:n-1] ^ c[0:n-1]
```

这样，我们可以得到PRG的前n位输出，若n>17（一般说来肯定大于），则我们可以尝试爆破17位LFSR的值，来猜测密钥，具体做法如下：

* 获取PRG的前n位输出 PRG[0:n-1]

* 猜测17位LFSR初始值，并输出前n位 LFSR1[0:n-1]

* 获取25位LFSR输出

  ```
  LSFR2[0:n-1] = (PRG[0:n-1] - LFSR1[0:n-1]) mod 256
  ```

* 使用输出反推LFSR2初始值，并通过密文c验证生成序列的正确性

这样复杂度仅为2^17

#### eStream

##### Salsa20

###### 输入输出

输入一个128或256b的密钥和一个64位的nonce
$$
Salsa20: \{0,1\}^{128 \ or \ 256} \times \{0,1\}^{64}  \rightarrow \{0,1\}^n
\\
Salsa20(k,r) = \ H(k, (r,0)) \ || \ H(k, (r,1)) \ || \ H(k, (r,2)) ...
$$
具体见https://www.ecrypt.eu.org/stream/project.html

## 分组密码

### PRP和PRF

#### PRF 伪随机函数

$$
F: K \times X \rightarrow Y
$$

其中K为密钥空间，X为输入空间，Y为输出空间

* 只要求有一个可行的算法计算F(k,x)

#### PRP 伪随机置换

$$
E: K \times X \rightarrow X
$$

* 有一个可行算法计算E(k,x)
* E(k,x) 是一一映射的
* 有一个可行的逆向算法 D(k,y)

#### PRF安全性

##### 记号

令F为一个PRF，有
$$
F: K \times X \rightarrow Y
$$
定义记号
$$
\left\{ 
\begin{aligned}
& Funs[X,Y]: 将X映射到Y的所有函数的集合
\\
& S_F = \{k \in K | F(k,·)\} \subseteq Funs[X,Y]
\end{aligned}
\right.
$$
SF定义了对应不同密钥时，X到Y的不同映射的函数。Funs定义了对应不同密钥及不同明文时的映射

对于密钥空间为2^n，密文空间为2^m的密码，其Funs[X,Y]大小为$2^{n^{2^m}}$，而其$S_F = 2^n$

##### 定义

当在Funs[X,Y]取一个随机函数，在SF中也取一个随机函数时，两者是不可区分的。

**简单来说**，就是假设有人用Funs中取的函数加密一段信息，或用SF中的加密同一段信息，他无法直接区分返回值是用哪个函数加密的

##### 形式化定义

定义一个实验EXP(b)，如下：

实验中有一个挑战者和一个攻击者，攻击者发送消息$x_1,x_2,...,x_q$，挑战者根据EXP(b)的b值决定返回如下两种值
$$
\begin{aligned}
& b=0: k \leftarrow K, f \leftarrow F(k,·)
\\
& b=1: f \leftarrow Funs[X,Y]
\\
& 返回f(x_1),f(x_2),...,f(x_q)
\end{aligned}
$$
此时攻击者A判断返回的f是当b=0还是b=1的，并给出自己的推断b'，作为EXP(b)的返回值

**简单来说**，EXP(0)=1，当挑战者的返回值是经过$f \leftarrow F(k,·)$加密的值但攻击者A认为该值是经过$f \leftarrow Funs[X,Y]$加密的

因此优势（advantage）为：
$$
Adv_{PRP}[A,E] = |\  P[EXP(0)=1] - P[EXP(1)=1] \ |
$$

##### 例子：一位异或是安全的PRP

令密钥空间为`K = {0,1}`，明文空间为`X = {0,1}`

对于1bit的空间，共有两种置换方式，分别为`f(0)=0  f(1)=1`和`f(0)=1  f(1)=0`。若`E(k,x) = x^k`，则因为E根据随机的k来选择x到y的映射方式（异或的性质），与在Funs[X,Y]中随机选取一个函数来加密x的概率分布是一致的

##### 例子：一位异或是不安全的PRF

因为不同于置换，一位PRF一共有四种：

* `f(0)=0  f(1)=1`
* `f(0)=1  f(1)=0`
* `f(0)=0  f(1)=0`
* `f(0)=1  f(1)=1`

因此可以简单地通过判断f(0)与f(1)有没有可能相等来区分

设计x=0和x=1输入，若f(1)=f(0)则输出1，则`P(EXP(0) = 1) = 0`，`P(EXP(1) = 1) = 0.5`，所以优势为0.5

##### PRF与PRP安全性的关系

若E是(K,X)上一个安全的PRP

若攻击者A最多可以发送q次查询，则
$$
| \  Adv_{PRF}[A,E] - Adv_{PRP}[A,E] \  | < \frac{q^2}{2|X|}
$$
即**若明文空间|X|足够大，则一个安全的PRP必是一个安全的PRF**

#### 使用PRF构造PRG

若F是一个安全的PRF
$$
F: K \times \{0,1\}^n \rightarrow \{0,1\}^n
$$
则下列的G是一个安全的PRG
$$
G: K \rightarrow \{0,1\}^{nt}
\\
G(k) = f(k,0) \ || \  f(k,1) \ || \  ... \ || \ f(k,n)
$$

### Feistel网络

#### 目标

构造一个可逆的函数F，对于$fi: \{0,1\}^n \rightarrow \{0,1\}^n, i \in [1,d]$，有
$$
F: \{0,1\}^{2n} \rightarrow \{0,1\}^{2n}
$$

#### 实现

架构图可见密码编码学笔记，这里写公式

##### 加密

将输入分为L和R两部分，长度分别为n
$$
\begin{aligned}
& L_i = R_{i-1}
\\
& R_i = L_{i-1} \oplus f_i(R_{i-1})
\end{aligned}
$$

##### 解密

将刚刚的公式反推
$$
\begin{aligned}
& R_i = L_{i+1}
\\
& L_i = R_{i+1} \oplus f_{i+1}(R_i) = R_{i+1} \oplus f_{i+1}(L_{i+1})
\end{aligned}
$$

### 分组加密中密文与明文对的唯一性

#### 引理1

假设DES是理想的加密算法，即DES的fi函数输出的伪随机数是安全的。那么DES加密明文相同的情况下，密钥产生碰撞的概率为1/256

#### 证明

这里即计算下式概率
$$
P[\exist k^{'} \neq k : c=DES(k,m) = DES(k^{'},m)]
$$
可知这个概率小于下式
$$
\sum_{k^{'} \in \{0,1\}^{56}} P[DES(k,m) = DES(k^{'},m)]
$$
又因为密钥为56位，密文分组为64位，因此密文碰撞概率为$\frac{1}{2^{64}}$，而不同密钥产生的不同映射数为$2^{56}$，因此总的碰撞概率为
$$
\sum_{k^{'} \in \{0,1\}^{56}} P[DES(k,m) = DES(k^{'},m)] \leq 2^{56} * \frac{1}{2^{64}} = \frac{1}{2^8}
$$
**简单来说**，这个引理证明了对于一个**理想的分组密码E**，密钥长度为n，分组长度为m，这里理想的含义即明文空间到密文空间的映射是随机的，且不同k造成的影响也是随机的。那么对于每个明文密文对，该密码有$（1-2^{n-m}）$的概率，k是唯一的

### DES

DES具体实现见编码学，这里主要讨论S盒

#### S盒

S盒是DES算法中唯一的非线性成分

##### 线性

首先假设一个线性S盒的情况：
$$
S_i(x_1, x_2, x_3) = (x_2 \oplus x_3, x_1 \oplus x_3, x_1 \oplus x_2)
$$
这样可以使用一个线性的矩阵表示该S盒

$$
S_i(x_1, x_2, x_3) = 
\begin{pmatrix}
0 & 1 & 1 \\
1 & 0 & 1 \\
1 & 1 & 0
\end{pmatrix}
\oplus
\begin{pmatrix}
x1 \\
x2 \\
x3
\end{pmatrix}
$$
对于这样的S盒，假设分组长度为x，轮密钥长度为y，加密轮数为n，则加密算法实则为一个`x*(x+y*n)`矩阵与一个`(x+y*n)*1`矩阵的运算，即
$$
E(k,m) = 
\begin{pmatrix}
B
\end{pmatrix}
·
\begin{pmatrix}
m \\
k_1 \\
k_2 \\
... \\
k_n
\end{pmatrix}
$$
其中，B为`x*(x+y*n)`矩阵，因为密文分组长度为x，且每一位的输出取决于m和k1到kn

**攻击**：此时若计算$E(k,m1) \oplus E(k,m2) \oplus E(k,m3)$，则等价于
$$
\begin{aligned}
B ·
\begin{pmatrix}
m_1 \\
k
\end{pmatrix}
\oplus
B ·
\begin{pmatrix}
m_2 \\
k
\end{pmatrix}
\oplus
B ·
\begin{pmatrix}
m_3 \\
k
\end{pmatrix}
&= B ·
\begin{pmatrix}
m_1 \oplus m_2 \oplus m_3 \\
k \oplus k \oplus k
\end{pmatrix}
\\
&= B ·
\begin{pmatrix}
m_1 \oplus m_2 \oplus m_3 \\
k
\end{pmatrix}
\\
&= E(k,m_1 \oplus m_2 \oplus m_3)
\end{aligned}
$$

#### DES的攻击方法

##### 穷举

这里原视频证明了上面小节**分组加密中密文明文对的唯一性**

###### 攻击

因为密钥长度仅为56位，因此可以通过**已知明文攻击**遍历密钥，即假设有一段DES加密的内容c1 ... cn，已知x个密文对应的明文m1 ... mx，则可以在可以接受的时间内爆破密钥

##### 侧信道

###### 时间

###### 能量

* 直接测试
* 差分攻击

###### cache miss

##### fault attack

当密码算法因为某些原因运行错误时（如调高频率、加热芯片等），可以从一些数据还原密钥（神奇

##### 线性和差分密码攻击

已知线性密码攻击有如下性质（这里不讨论怎么证明）
$$
P[ (m_{i1} \oplus ... \oplus m_{ir}) \oplus (c_{j1} \oplus ... \oplus c_{jv}) = k_{l1} \oplus ... \oplus k_{lu}] = \frac{1}{2} + \epsilon
$$
对于DES来说，$\epsilon = \frac{1}{2^{21}}$

出现这种性质是由于第5个S盒出现了一些线性成分

###### 攻击

获取$\frac{1}{\epsilon^2}$对明文密文对，统计下值的众数
$$
(m_{i1} \oplus ... \oplus m_{ir}) \oplus (c_{j1} \oplus ... \oplus c_{jv})
$$
则该值等于$k_{l1} \oplus ... \oplus k_{lu}$的概率为97.7%，因为
$$
\begin{aligned}
& 相等的明文密文对理论上为：\frac{1}{\epsilon^2} * (\frac{1}{2}+\epsilon) = \frac{1}{2*\epsilon^2} + \frac{1}{\epsilon}
\\
& 不等的个数理论上为：\frac{1}{2*\epsilon^2} - \frac{1}{\epsilon}
\end{aligned}
\\
所以二者数量为以上述两式为数学期望\mu的正态分布
$$
运用该原理，可以从S5中还原14位的密钥（原理没讲）。因此可以将搜索空间降低到2^43（2^42+2^42）

#### DES的改进

##### 3DES

###### 密钥长度

168b（56*3）

###### 分组长度

64b

###### 加密方法

将密钥$k_{168}$分解成3个密钥$k_{56}:k_1,k_2,k_3$
$$
c = E(k_1,D(k_2,E(k_3,m)))
$$
其中E和D对应DES的加密和解密

###### 为什么是EDE

这是一个trick，若$k_1 = k_2 = k_3$则效果等价于DES，对于硬件设计来说可以少设计一些组件，虽然速度较慢

###### 为什么不能是2DES

假设提出一种2DES算法，下面提出一种破解方法
$$
2DES((k_1,k_2),m) = E(k_1, E(k_2,m))
$$

###### 中途相遇攻击(meet in the middle)

这个算法可以被中途相遇攻击破解，方法如下

因为$c = E(k_1, E(k_2,m))$，因此$D(k_1, c) = E(k_2, m)$

此时已知c，遍历k打表D(k,c)并排序，复杂度为$2^{56}log_2 2^{56} < 2^{63}$

又因为已知m，遍历k2打表E(k,m)并排序，复杂度同上

在两边寻找碰撞，若找到了则对应$k_1,k_2$为密钥，复杂度小于$2^{64}$，远小于密钥长度

**此外，3DES也可以使用该方法攻击，但复杂度大于2^112**

##### DESX

一种较快的方法，可以抵御穷举攻击，但不能防御其他一些攻击
$$
DESX((k_1,k_2,k_3),m) = k_1 \oplus E(k_2, m \oplus k_3)
$$
**这里的异或必须在加密函数内外都做运算，否则完全无效**

### AES

#### 密钥长度

128b 192b 256b

#### 分组长度

128b

#### 实现

具体时间见密码编码学，这里大致说下过程和操作

AES不是基于Feistel网络的，所以每次加密都是对分组的所有元素进行操作（Feistel每轮只操作一半）

##### 初始化

分组长度128b，即16byte，分为4*4的状态矩阵

##### 轮函数

AES每轮有三个函数，分别为

* ByteSub  一个8b -> 8b的S盒，且逆S盒可求（DES的S盒是6b->4b，不可求）
* ShiftRows  循环移位
* MixColumns  列混合

##### 轮密钥加

每次轮函数运行完得到的状态矩阵跟子密钥异或后作为下一个轮函数的输入

##### 最后一轮

最后一轮没有列混合

#### 攻击

一种还原密钥的攻击对于AES128可以提升4倍效率

相似密钥攻击对于AES256可以将复杂度从2^256提升到2^99，要求是拥有来自4个只有个别位不同的2^99对明文密文对。原理是AES256密钥扩展时的bug

### 由PRG构造分组密码

#### 目标

由于**分组密码可以由feistel网络+PRP（伪随机置换）组成**，因此实际目标是PRG -> PRF -> PRP

#### PRG -> PRF

PRG接收一个固定的种子seed，因此PRG的形式为`PRG(k)`，假设第一次的PRG输出为`PRG(k)[0]`，第n次为`PRG(k)[n]`

而PRF的形式为`PRF(k, x)`

##### 一种构造方法

###### 扩展为1位PRF

令$G: K \rightarrow K^2，且G是一个安全的PRG$

构造一个1bit输入的PRF
$$
\begin{aligned}
& F: K \times \{0,1\} \rightarrow K
\\
& F(k,x \in \{0,1\}) = G(k)[x]
\end{aligned}
$$
即F可以看成下面描述

```
       k
     / G \
G(k)[0]  G(k)[1]
```

###### 扩展为2位

$$
\begin{aligned}
& G_1(k) = G(G(k)[0]) \  || \ G(G(k)[1]))
\\
& F(k,x \in \{0,1\}^2) = G_1(k)[x]
\end{aligned}
$$

即

```
               k
             / G \
     G(k)[0]       G(k)[1]
    /   G   \     /   G   \
   00       01   10        11
```

###### 扩展为n位

按上面的方式扩展下来

###### 安全性分析

因为G为安全的PRG，因此输出G(k)[0]和G(k)[1]与真随机数无法区分，即两者可以被视为真随机数r0 r1

那么第二次G运算时输入的k为真随机数，因此得到的两种输出都可以视为真随机数，以此类推

##### GGM PRF

$$
\begin{aligned}
& 对于输入 x = x_0 x_1 ... x_{n-1}
\\
& k \stackrel{G(k)[x_0]}{\longrightarrow} k_1 \stackrel{G(k)[x_1]}{\longrightarrow} k_2 ... k_{n-1} \stackrel{G(k_{n-1})[x_{n-1}]}{\longrightarrow} output
\end{aligned}
$$

理论上这种PRF虽然是不可逆的，但可以通过Feistel网络构造PRP，不过这种PRF效率很低，不实用

### 分组加密方式

#### ECB 电码本模式

将明文分成m1 m2 ... mn，直接计算
$$
c_1 = E(k,m_1)
\\
c_2 = E(k,m_2)
\\
...
\\
c_n = E(k,m_n)
$$
十分不安全，因为若m1=m2则c1=c2，可以用语义安全的定义对其加以证明

#### CTR 计数器模式

类似于流密码，将分组密码作为PRF使用
$$
c_1 = m_1 \oplus E(k,1)
\\
c_2 = m_1 \oplus E(k,2)
\\
...
\\
c_n = m_n \oplus E(k,n)
$$

##### 改进

随机计数器随机一个初始计数值IV，下面n个分组每次使用$c_n = m_n \oplus F(k,IV+n)$进行加密

##### 安全性分析

CTR模式在CPA攻击下的优势如下式
$$
Adv_{CPA}[A,E_{CBC}] \leq 2*Adv_{PRP}[B,E] + \frac{2 q^2L}{|X|}
$$

###### 例子

对于使用CTR的AES128，因为$Adv_{PRP}[B,E]$是可忽略的，令其小于$\frac{1}{2^{32}}$，则（忽略常数项2）
$$
\frac{q^2}{|X|} < \frac{1}{2^{32}}
\\
因为|X| = 2^{128}，所以
\\
q^2 < 2^{96}
\\
q < 2^{48}
$$
即对于AES128，使用CTR模式时加密2^48个分组后应该更换密钥k

#### CBC 分组链接模式

选取一个初始向量IV
$$
c_1 = E(k,IV \oplus m_1)
\\
c_2 = E(k,c_1 \oplus m_2)
\\
...
\\
c_n = E(k,c_{n-1} \oplus m_n)
$$

##### 安全性分析

CBC模式在CPA攻击下的优势如下式
$$
Adv_{CPA}[A,E_{CBC}] \leq 2*Adv_{PRP}[B,E] + \frac{2 q^2L^2}{|X|}
$$
其中L为加密的明文分组数，q是使用同一个密钥加密的次数

###### IV可预测的攻击

* 攻击者A询问密文$m_0 = m_1 = 0$的加密，因此加密实际为$c = E(k, IV_1 \oplus 0) = E(k,IV_1)$
* 攻击者A询问密文$m_0 = IV_1 \oplus IV_2$的加密， $c = E(k, IV_2 \oplus (IV_1 \oplus IV_2)) = E(k, IV_1)$
* 因此若上述查询返回的是m0加密值，则应该跟第一次查询值相等，否则被加密的是m1，即攻击者A可以通过密文猜测被加密的消息

###### 防御手段

不直接传入IV，而是指定一个nonce和k1，如下
$$
IV = E(k_1, nonce)
$$
nonce可以是固定值，**但k1不能使用和分组加密相同的k**

##### pad

在CBC模式中，pad必须被使用，但对于CTR等模式，因为本质上是PRF产生序列与明文异或，因此不需要pad

###### PKCS-5

在填充的每个字节中写入填充的字节数

这种方法在分组长度为密文分组整数倍的时候需要单独填充一个完整的分组（dummy block），以防止解密程序错将明文的最后一位当成pad长度

### 攻击

#### 选择明文攻击 (Choosen Plaintext Attack)

即攻击者可以选择要加密的明文m1并获取E(k,m1)，从而用于破解用相同k加密的其他明文mn

**当对于相同的明文会产生相同的加密结果时，则密码对于选择明文攻击是不安全的**，因为由语义安全定义出发，攻击者A可以通过选择自己要加密的值m0 m1，比如在第一次加密时令m0=m1=m，获取m0的加密值。则在第二次加密时可以轻易区分EXP(0)和EXP(1)，因为若第二次令m0=m m1=n，则可以通过前面结果判断返回的是m的加密结果还是n

**ECB无法抵御选择明文攻击**

##### 抵御方法

###### 基于新鲜值(nonce)的加密

除了有密钥外，还随机选取一个新鲜值r，计算E(k,r,m)作为密文（如$F(k,r) \oplus m$），并且发送r作为解密依据。优点是若r空间足够大，则相同明文的加密结果大概率不同，缺点是要额外发送一个r值，多占空间。但对于类似CTR的新鲜值加密，可以做到不发送r值（比如通信双方协商使用包计数作为新鲜值）。

###### 基于新鲜值加密的CPA安全性

攻击者A可以进行q次查询，并且指定新鲜值，唯一限制是指定的新鲜值不能相同。每次发送$m_{i,0},m_{i,1}和新鲜值n_i$，挑战者返回$E(k,m_{i,b},n_i)$，攻击者A猜测返回值是对m0还是m1的加密。

如果攻击者A优势为0，则称其CPA安全

## 消息验证码

定义MAC算法`I = (S,V)`，要求
$$
\begin{aligned}
& 发送方签名
\\
& t = S(k,m)
\\
& 接收到对方发送的(m',t')，当且仅当(m',t') = (m,t)
\\
& V(k,m',t') = True
\end{aligned}
$$

### 构建

可以直接由PRF构建MAC，具体方法如下

假设有一个安全的PRF $F:K \times X \rightarrow Y$，定义`I = (S,V)`
$$
\begin{aligned}
& S(k,m) = F(k,m)
\\
& V(k,m,t) = 1，当 t = F(k,m)
\end{aligned}
$$
但这里存在着一个问题，即对于明文空间确定的PRF，应怎样拓展使其可以处理更长的输入

#### CBC-MAC(ECBC)

定义 $F_{ECBC} : K^2 \times X^{\leq L} \rightarrow X$
$$
\begin{aligned}
tmp_0 &= F(k,m_0)
\\
tmp_1 &= F(k,m_1 \oplus tmp_0)
\\
& ...
\\
tmp_{L-1} &= F(k, m_{L-1} \oplus tmp_{L-2})
\\
tag &= F(k_1, tmp_{L-1})
\end{aligned}
$$
**简单来说**，就是以前一个分组的PRF与下一个分组异或后计算下一个分组的值

**注意**，这里最后一次PRF使用了不同的密钥，否则有安全性问题

##### 安全性分析

$$
Adv_{PRF}[A,F_{ECBC}] \leq Adv_{PRP}[B,F] + 2 \frac{q^2}{|X|}
$$

#### NMAC

级联函数
$$
\begin{aligned}
tmp_0 &= F(k, m_0)
\\
tmp_1 &= F(tmp_0, m_1)
\\
...
\\
tmp_{L-1} &= F(tmp_{L-2}, m_{L-1})
\\
tag &= F(k_1, tmp_{L-1} || fpad)
\end{aligned}
$$
**简单来说**，就是以前一个分组的PRF值作为下一个分组PRF密钥

**注意**，这里最后一次PRF也使用了不同的密钥

##### 安全性分析

$$
Adv_{PRF}[A,F_{NMAC}] \leq q*L*Adv_{PRF}[B,F] + \frac{q^2}{2|K|}
$$

#### CMAC

很类似CBC-MAC的方式，但最后一块与CBC-MAC不一样，并因此提供了较为独特的pad方式（见下面pad）
$$
\begin{aligned}
tmp_0 &= F(k,m_0)
\\
tmp_1 &= F(k,m_1 \oplus tmp_0)
\\
& ...
\\
tmp_{L-1} &= F(k, m_{L-1} \oplus tmp_{L-2})
\\
当m_L与分组长度不同时：
\\
tag &= F(k, (m_{L}||pad) \oplus tmp_{L-1} \oplus k_1)
\\
当m_L与分组长度相同时：
\\
tag &= F(k, m_{L} \oplus tmp_{L-1} \oplus k_2)
\end{aligned}
$$

#### PMAC

可以并行计算的MAC
$$
\begin{aligned}
tmp_0 &= F(k_1, m_0 \oplus P(k,0))
\\
tmp_1 &= F(k_1, m_1 \oplus P(k,1))
\\
...
\\
tmp_{n-2} &= F(k_1, m_{n-2} \oplus P(k,n-2))
\\
tmp_{n-1} &= m_{n-1} \oplus P(k,n-1)
\\
tag &= F(k_1, tmp_0 \oplus ... \oplus tmp_{n-1})
\end{aligned}
$$
**注意** 最后一块没有经过F，所有分组的c算完后一起异或并传入F计算

##### 分组交换攻击

对于并行MAC的设计，若没有如PMAC中与一个P(k,i)异或而是直接将$m_0,...,m_{n-1}$输入F，一个可行的攻击为：交换j个分组，最后得到的MAC是不变的

##### 安全性分析

$$
Adv_{PRF}[A,F_{PMAC}] \leq Adv_{PRF}[B,F] + \frac{2q^2L^2}{|X|}
$$

##### PMAC的递推性质

与CBC-MAC等不同，PMAC有如下性质：若知道消息$m_0,...,m_i,...,m_{n-1}$的tag，要计算$m_0,...,m'_i,...,m_{n-1}$的tag'，可以采用如下方法：
$$
tag' = F^{-1}(k_1,tag) \oplus F(k_1, m[i] \oplus P(k,i)) \oplus F(k_1, m'_1 \oplus P(k,i))
$$
该性质在F为PRP的情况下成立，并且很容易证明

#### One-Time MAC

密钥只能使用一次的MAC，容易构造，并且能保证知道`tag1 = S(k,m1)`的情况下无法猜测`tag2 = S(k,m2)`

但需要注意，**当攻击者同时知道tag1和tag2时，该算法可以被预测**

##### 一种设计

令q为一个大素数，取密钥对$key = (k,a) \in \{1,...,q\}^2$，若密文$msg = (m_1,...,m_L)$
$$
S(key,msg) = P_{msg}(k) + a (mod \ q)
$$
其中，P(x)是关于x的多项式 $P_{msg}(x) = m_L x^L + ... + m_1 x$，其中x^L代表x的第L位

##### 扩展：Carter-Wegman MAC

设(S,V)是一对one-time MAC的签名和验证算法，F是一个安全的PRF，都定义在$\{0,1\}^n$上
$$
CW((k_1,k_2), m) = (r, F(k_1,r) \oplus S(k_2,m))
$$
这里的r是一个n位随机数

 **注意**，因为这里的r为随机数，因此对同一信息的MAC可能不同。这种算法将简单快速的one-time MAC用于长信息的验证，最后将结果加密（F速度较慢），这样使得整个算法速度变快

验证过程如下：
$$
V(k_2, m, tag \oplus F(k_1,r))
$$

#### 最后一次PRF

最后一次PRF需要使用不同的k，因为如果没有最后一次使用不同密钥的PRF，试想攻击者A做如下操作

##### NMAC的扩展攻击

对于NMAC

- 发送$m_0 || m_1 || ... || m_{q-1}$
- 获取tag1

可以这样构造$m_0||m_1||...||m_{q-1}||m_{q}$的MAC：$tag = F(tag_1, m_{q})$

##### CBC-MAC的扩展攻击

对于CBC-MAC

* 发送$m_0 || m_1 || ... || m_{q-1}$
* 获取tag1
* 发送$m'_q = m_q \oplus tag1$
* 获取tag2

因为$tag2 = F(k,m'_q)$，而$tag = F(k, tag1 \oplus m_q)$，所以tag2 = tag，即可以算出$m_0 || m_1 || ... || m_{q-1}|| m_{q}$的tag

#### pad

当消息长度不够时，需要pad补齐字节

##### 错误的pad

如在最后一块消息m后补0，因为这样m的tag与`m||0`的tag将会相同

##### pad方式

###### 补100...

补齐`100...00`，且若分组长度可被整除则多补齐一个dummy block

###### CMAC的方式

CMAC将密钥k扩展为k1和k2

* 若信息长度不为分组整数倍，则最后输出为 $tag = F(k, (m_w || 100) \oplus k_1 \oplus tmp_{w-1})$
* 若信息长度为分组整数倍，则最后输出为 $tag = F(k,m_w \oplus k_2 \oplus tmp_{w-1})$

这样可以避免多出一个dummy block，并且CMAC由于这一步的存在而不需要与CBC-MAC一样在最后一步使用不同密钥加密

### 安全性

#### MAC安全性分析

对于安全的PRF $F:K \times X \rightarrow Y$，有
$$
Adv_{MAC}[A,I_F] \leq Adv_{PRF}[B,F] + \frac{1}{|Y|}
$$
|Y|为PRF的密文空间

**证明如下**

因为假设PRF是安全的 ，因此可以使用真随机数$f: X \rightarrow Y$来替代F

则攻击者A发送消息 $m_1,...m_q$，得到的消息为$t_1,...,t_q$，此时要从这些信息预测一个全新的m的t值，则预测正确的概率为$\frac{1}{|Y|}$，因为f是真随机数

#### 攻击者

##### 选择消息攻击

攻击者可以发送消息$m_1,m_2,...,m_q$，获取其使用密钥k生成的MAC $t_i = S(k,m_i)$

##### 存在性伪造

这是攻击者的目标，即攻击者可以产生一个消息/验证码对(m,t)，使得
$$
(m,t) \notin \{(m_1,t_1),...,(m_q,t_q)\}
$$
**简单来说**，就是攻击者不可能在不知道密钥的情况下构造一个(m,t)使其可以通过验证。同理还有个推论，对于(m,t)，不可能给出t'，使得(m,t')可以通过验证

#### 形式化定义

对于MAC算法 `I = (S,V)`

* 攻击者A向挑战者发送q个明文$m_1,m_2,...,m_q$
* 挑战者返回 $t_n = S(k,m_n)$
* 攻击者A构造一个$(m,t) \notin \{(m_1,t_1),...,(m_q,t_q)\}$给挑战者验证
* 挑战者执行 V(k,m,t)，若为真，则输出为真

**优势**
$$
Adv_{MAC} [A,I] = P(Challenge \ output \ 1)
$$

### 攻击

#### 认证信息交换

如攻击者A截获了B**先后**发送的两段信息 $(m_0.t_0),(m_1,t_1)$

MAC可以保证m0和m1不被篡改，但无法保证m0和m1的先后次序，即攻击者A可以通过颠倒m0 m1的发送顺序来完成一些攻击

#### 碰撞

对于CBC-MAC和NMAC，都有下列性质成立：若有碰撞发生在$x = x_0 || ... || x_i和y = y_0 || ... || y_j$
$$
F_{BIG}(k,x) = F_{BIG}(k,y)
$$
则
$$
F_{BIG}(k, x||w) = F_{BIG}(k,y||w)
$$
原因很简单，若上述式子成立，则说明$tmp_{xi} = F(k, tmp_{i-1} \oplus x_i)$与$tmp_{yj} = F(k, tmp_{j-1} \oplus y_j)$相等，因此对于两边的加密来说，因为下一块加密值只取决于$tmp_{n-1}和m_n$，因此两者也会碰撞

##### 生日攻击

对于MAC：$F_{BIG}: K \times X \rightarrow Y$

* 攻击者A获取$|Y|^{\frac{1}{2}}$对明文密文对

* 由生日悖论可以得到，可以以很高的概率从中找到一对碰撞$t_u = t_v$

* 则按照上面的结论，两对碰撞的明文后面附加w的哈希值也会碰撞
  $$
  F_{BIG}(k, m_u || w) = F_{BIG}(k, m_v||w)
  $$

## HASH

### 抗碰撞性

令$H:M \rightarrow T$为一个哈希函数

碰撞定义为存在 $m_0,m_1 \in M$，且$m_0 \neq m_1$有
$$
H(m_0) = H(m_1)
$$
我们称哈希函数H是抗碰撞的，当没有一个有效的算法A能计算出与m0的哈希值碰撞的m

#### 使用HASH构造MAC

$$
S^{big}(k,m) = S(k,H(m))
\\
V^{big}(k,m,t) = V(k,H(m),t)
$$

与前面构造长输入的MAC的方法不同，这里不对MAC的算法进行扩展，而是直接使用F加密一个用HASH函数生成的tag，只要HASH是抗碰撞的，MAC一样可以是安全的

### 构建

#### 由短的哈希构建长哈希

最常用的做法称为Merkle-Damgard结构

假设压缩函数 $h: T \times X \rightarrow T$
$$
\begin{aligned}
H_0 &= IV
\\
H_1 &= h(H_0, m_0)
\\
H_2 &= h(H_1, m_1)
\\
...
\\
H_n &= h(H_{n-1}, m_{n-1})
\\
output &= H_n
\end{aligned}
$$


### 攻击

#### 生日攻击

定义在上面已经给过，这里给出证明

令$r_1,...,r_n \in \{1,...,B\}$为独立的数，则其中没有碰撞的概率为：
$$
\frac{B-1}{B} * \frac{B-2}{B} * ... * \frac{B-n+1}{B} = \frac{B!}{(B-n)! * B^n}
$$
因此存在碰撞的概率为
$$
\begin{aligned}
1 - \frac{B!}{(B-n)! * B^n}  &= 1 - \prod^{n-1}_{i=1}(1-\frac{i}{B})
\\
& \geq 1 - \prod^{n-1}_{i=1}e^{-\frac{i}{B}}
\\
& = 1 - e^{- \frac{1}{B} \sum^{n-1}_{i=1}i}
\\
& \geq 1 - e^{-\frac{n^2}{2B}}
\end{aligned}
$$
注意连乘处的变换$\frac{B-i}{B} = 1 - \frac{i}{B}$

还有不等式$1-x \leq e^{-x}$，由于$e^{-x} = 1 - x + \frac{x^2}{2!} - \frac{x^3}{3!}...$

**生日攻击说明了对于n位的HASH，要找到碰撞需要的时间复杂度为**$O(2^{\frac{n}{2}})$

## 论文

### MAC

![](pic\stanford_MAC_1.png)

## 问题

0002 131:00 proof of claim 2，B算法中A给出m0和m1，接收m0^y作为输入，那m1是干嘛的。然后这段证明没怎么看懂

0003  PRG->PRF  为什么构造PRF时不直接这样： F(k,x) = G(k)[x]。若G符合安全性假设则理论上这样也能得到安全的PRF（可能是因为实际上PRG不可能是安全的）

#### 问题3

为什么 足够大的PRP也是一个安全的PRF？

理论上说对于n位的输入映射到n位的输出，置换数一共为$(2^n)!$，但函数个数一共为$(2^n)^{2^n}$，也就是说一定能从统计上看出两者区别。难道只是因为q值太小而很难碰撞到么

因为
$$
\frac{n!}{n^n} = \frac{1}{n} * \frac{2}{n} * ... * \frac{n}{n} \leq \frac{1}{n}
$$

* 攻击者A发送m给challenger
* challenger发送：b=0: c = PRP(m)  b=1: c = PRF(m)
* 攻击者A根据c猜测m经过PRF还是PRP

因为要区分一个函数是PRP还是PRF，应该通过该性质：
$$
\exist m_0,m_1 \in M, PRF(m_0) = PRF(m_1)
$$
对于一个PRF，假设其中有x个重复的映射，即存在$m_1,m_2,...,m_x$，使得其函数值相等，计算函数个数





