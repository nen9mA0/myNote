## EFLAGS

```
15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
  |  |  |  |OF|DF|IF|TF|SF|ZF|  |AF|  |PF|  |CF
```

* OF  overflow
* DF  direct
* IF  中断允许
* TF  调试标志位
* SF  sign  符号
* ZF  zero
* AF  辅助进位（最后四位向前进位，用于BCD码计算
* PF  奇偶
* CF  进位

### CF

用于判断无符号数是否溢出

无符号数的溢出场景

* 上溢  `A+B > 2^n-1`
* 下溢  `A-B < 0`

CF判断不仅仅是根据补码运算是否溢出  https://stackoverflow.com/questions/12237725/carry-flag-in-substraction

```asm
MOV AX, 5
MOV BX, 10
SUB AX, BX

MOV AX, 5
MOV BX, 10
NOT BX
INC BX
ADD AX, BX
```

上面的sub与下面的add看似运算上等价（上面是减去某数，下面是加上某数补码），但对于flag的影响不一样。sub运行后CF=1，add运行后CF=0

这是因为在X86处理器中，对于sub运算，**CF值会被取反**，即没有溢出时反而CF会置0，有溢出时置1。不同处理器在这点的处置上不同。但对于所有处理器，add指令执行时CF都不会被取反

这样做的理由是，对于add，无符号数只会上溢（即结果大于2^n-1），而对于sub，无符号数只会下溢（即结果小于0）。对于`A-B = A+(-B)`，当A>B时，补码运算将溢出，但此时实际上sub并没有下溢；相反当A<B时，将发生下溢，但补码运算并没有溢出。因此部分处理器对于add与sub的处理不同

### OF

用于判断有符号数是否溢出

#### 计算场景

* $$
  A > 0, B > 0 \ \ A,B \in [0, 2^{n-1}-1]
  \\
  A+B \in [0,2^n-2]
  $$

* $$
  A < 0, B < 0 \ \ A,B \in [-2^{n-1}, -1]
  \\
  A+B \in [-2^n, -2]
  $$

* $$
  A > 0, B < 0 \ \ A \in [0, 2^{n-1}-1], \ \ B \in [-2^{n-1}, -1]
  \\
  A-B \in [1, 2^n-1]
  $$

* $$
  A < 0, B > 0 \ \ A \in [-2^{n-1}, -1] \ \ B \in [0, 2^{n-1}-1],
  \\
  A-B \in [-2^n-1, -1]
  $$

##### 对于8位数据

* ```
  A,B in (0x00, 0x7F)
  A+B in (0x00, 0xFE)
  ```

* ```
  A,B in (0x80, 0xFF)
  A+B in (0x100, 0x1FE)
  ```

* ```
  A in (0x00, 0x7F)  B in (0x80, 0xFF)
  A-B in (0x01, 0xFF)
  ```

* ```
  A in (0x80, 0xFF)  B in (0x00, 0x7F)
  A-B in (0x101, 0x1FF)
  ```

#### 溢出情景

##### 对于源操作数

下表的情况描述的是A与B作为指令源操作数的情况，即`ADD A,B  SUB A,B`

|          | 正+正   | 负+负   | 正-负   | 负-正   |
| -------- | ------- | ------- | ------- | ------- |
| MSB(A)   | 0       | 1       | 0       | 1       |
| MSB(B)   | 0       | 1       | 1       | 0       |
| MSB(SUM) | 0  /  1 | 0  /  1 | 0  /  1 | 0  /  1 |
| OF       | 0  /  1 | 1  /  0 | 0  /  1 | 1  /  0 |

即，当sum的符号与预期不一致时，则为溢出

整理上面真值表，可得解析式`OF = MSB(A) xor MSB(SUM)`

##### 对于加法器输入

下表的情况描述的是A与B输入加法器时的情况，即负数已经被转换为补码

|      |      |      |   A add B     |      |      |      | A sub B | |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      | 负+负 | 正+正 | 负+正 | 正+负 | 负+负 | 正+正 | 负+正 | 正+负 |
| MSB(A) | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 |
| MSB(B) | 1 | 0 | 0 | 1 | 0 | 1 | 1 | 0 |
| MSB(SUM) | 0 / 1 | 0 / 1 | 0 / 1 | 0 / 1 | 0 / 1 | 0 / 1 | 0 / 1 | 0 / 1 |
| OF | 1 / 0 | 0 / 1 | 0 / 0 | 0 / 0 | 0 / 0 | 0 / 0 | 1 / 0 | 0 / 1 |

整理上述真值表，可得解析式`OF = ( MSB(A) EOR MSB(B) ) AND ( MSB(A) XOR MSB(SUM) )

### 加减法与EFLAGS

注意，对于补码运算来说，CF位与实际情况相反，减法向上借位时为0，无借位时为1

```
0x01 - 0x02 = 0x01 + 0xFE = 0xFF   --> 借位, CF=0
0x02 - 0x01 = 0x02 + 0xFF = 0x1_01 --> 无借位, CF=1
```

