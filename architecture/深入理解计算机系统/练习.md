## 第二章

### 2.11

#### A

first = last = k

#### B

因为最后一次相当于

```
a[first] ^ a[last] = a[k] ^ a[k] = 0
```

#### C

将条件

```
first <= last
```

改为

```
first < last
```

### 2.12

#### A

```CQL
x = x & 0xff;
```

#### B

```c
x = (~x & ~0xff) | (x & 0xff);
```

#### C

```c
x = x | 0xff;
```

### 2.13

```
bis(x, m) = x | m
bic(x, m) = x & ~m

xor = (a & ~b) | (~a & b)
```

```c
int bis(int x, int m);
int bic(int x, int m);

int bool_or(int x, int y)
{
    int result = bis(x, m);
    return result;
}

int bool_xor(int x, int y)
{
    int result = bis(bic(x, m), bic(m,x));
    return result;
}
```

### 2.15

等价于x==y的表达式

```
!(x^y)
```

### 2.16

* x
  * 0xC3
  * 0x75
  * 0x87
  * 0x66
* 二进制
  * 1100 0011
  * 0111 0101
  * 1000 0111
  * 0110 0110
* x << 3
  * 0x18
  * 0xA8
  * 0x38
  * 0x30
* x >> 2  逻辑
  * 0x30
  * 0x1D
  * 0x21
  * 0x19
* x >> 2  算术
  * 0xF0
  * 0x1D
  * 0xE1
  * 0x19

### 2.17

对于4位数，对应的二进制 无符号数 有符号数

* 0x0
  * 0000
  * 0
  * 0
* 0x5
  * 0101
  * 5
  * 5
* 0x8
  * 1000
  * 8
  * -8
* 0xD
  * 1101
  * 13
  * -3
* 0xF
  * 1111
  * 15
  * -1

### 2.19

4位有符号转无符号

```
-8 -> 8
-3 -> 13
-2 -> 14
-1 -> 15
 0 -> 0
 5 -> 5
```

### 2.21

32位机上下列表达式的值

有符号与无符号运算会将有符号提升为无符号

```
-2147483647-1 == 2147483648U
    0x8000 0000 -> 2147483648U
    所以True
-2147483647-1 < 2147483647
    无溢出，无类型转换
    所以True
-2147483647-1U < 2147483647
    -2147483648 -> 0x8000 0000 -> 2147483648U
    所以False
-2147483647-1 < -2147483647
    无溢出无类型转换
    所以True
-2147483647-1U < -2147483647
    -2147483647 -> 0x8000 0001 -> 2147483649
    -2147483648 -> 0x8000 0000 -> 2147483648
    所以True
```

### 2.23

分别写出`(int) ((word << 24) >> 24)`和`((int) word << 24) >> 24` 的结果

```
0x0000 0076
    0x0000 0076
    0x0000 0076
0x87654321
    0x0000 0021
    0x0000 0021
0x0000 00C9
    0x0000 00C9
    0xFFFF FFC9
0xEDCBA987
    0x0000 0087
    0xFFFF FF87
```

### 2.24

4位截断到3位

```
无符号        补码
原始值 截断值 原始值 截断值
0      0      0      0
2      2      2      2
9      1      -7     1
B      3      -5     3
F      7      -1     -1
```

### 2.25

因为unsigned中，0-1=0xffffffff=4294967295

### 2.26

strlen(s) < strlen(t)时，因为这种情况下strlen(s)-strlen(t)下溢。改进方法强制转换strlen返回值？

### 2.30

```c
int tadd_ok(int x, int y)
{
    unsigned int mask = 1 << (sizeof(unsigned int)*8-1);
    return ( !((x&mask)^(y&mask)) && (x&mask)^((x+y)&mask) );
}
```

判断溢出的条件就是当x和y同号，且和x+y异号时溢出

mask用于取符号位，(x&mask)^(y&mask)当x和y符号位相同时为0，则!(x&mask)^(y&mask)当两者同号时为1。

(x&mask)^((x+y)&mask)当x和x+y异号时为1，这里x换成y也可。两个条件用&&结合起来即可判断

### 2.31

因为无论是否溢出，-x始终是x的逆元，因此等式一定是成立的

### 2.32
