## 第一章 量化设计与分析基础

### 并行度与并行体系结构的分类

#### 应用程序

* 数据级并行  Data Level Parallel
* 任务级并行  Task Level Parallel

#### 计算机硬件

硬件主要对下列四种开发并行应用程序的思想提供支持

* 指令集并行  在编译器帮助下利用流水线 推理执行思想开发数据级并行
* 向量体系结构和图形处理器
* 线程级并行
* 请求级并行

根据硬件本身支持数据级并行与任务级并行的方式可以分为下面几类

* 单指令集单数据流  SISD
* 单指令集多数据流  SIMD
* 多指令集单数据流  MISD
* 多指令集多数据流  MIMD

### 指令集体系结构

#### ISA分类

* 寄存器-存储器ISA  可以在指令中直接访问存储器（x86）
* 载入-存储ISA  只能通过载入（load）或存储（store）指令访问寄存器 （MIPS ARM）

#### 寻址

* ARM MIPS要求对齐，x86不要求
* 寻址模式
  * 寄存器寻址    MIPS x86 ARM
  * 立即数寻址    MIPS x86 ARM
  * 偏移量寻址
    * 偏移量+寄存器    MIPS x86 ARM
    * 绝对偏移量    x86（相对段寄存器的绝对偏移量）
    * 寄存器+寄存器    x86 ARM
    * 寄存器+n*寄存器    x86 ARM
    * 寄存器+n*寄存器+偏移量  x86
    * PC+偏移量    ARM
    * 自动递增/递减寻址    x86 ARM

#### 操作数类型

* 8b
* 16b
* 32b
* 64b
* float(32b)
* double(64b)
* long double(80b)    x86

#### 操作指令

常见的如下几类

* 数据传输指令
* 算术逻辑指令
* 控制指令
* 浮点指令

#### 跳转

* 无条件跳转
* 条件跳转
* 过程调用及返回

ARM和x86在条件跳转中是根据标志位，MIPS则是根据寄存器值

ARM和MIPS返回地址存在寄存器，x86则是压栈

#### 编码

* 定长    ARM MIPS
* 不定长    x86

ARM和MIPS为了缩小程序规模，出现了支持16位的指令集，分别为Thumb/Thumb-2  MIPS16

### 可信任度

#### 模块可靠性

* 平均无故障时间  MTTF
* 平均修复时间  MTTR
* 平均故障间隔时间  MTBF = MTTF+MTTR

$$
模块可用性 = \frac{MTTF}{MTTF+MTTR}
$$

对于多个独立组件构成的系统，假设寿命符合指数分布（大多数器件都符合）。故障率

### 基准测试

一般采用一组程序，来比较各个计算机的执行时间，每个程序都可以测试SPECRatio
$$
SPECRatio(A) = \frac{执行时间_{基准}}{执行时间_{A}}
$$
对于多组程序，一般取几何平均
$$
\sqrt[n]{\prod_{i=1}^{n} SPECRatio(A_i)}
$$
此时若对两台计算机的SPECRatio进行比较，则不需要考虑基准计算机的选取
$$
\frac{\sqrt[n]{\prod_{i=1}^{n} SPECRatio(A_i)}}{\sqrt[n]{\prod_{i=1}^{n} SPECRatio(B_i)}} = \sqrt[n]{\prod^{n}_{i=1}\frac{SPECRatio(A_i)}{SPECRatio(B_i)}} = \sqrt[n]{\prod^{n}_{i=1}\frac{\frac{执行时间_{基准}}{执行时间_{A_i}}}{\frac{执行时间_{基准}}{执行时间_{B_i}}}} = \sqrt[n]{\prod^{n}_{i=1}\frac{执行时间_{A_i}}{执行时间_{B_i}}}
$$

### 计算机设计的量化原理

#### 局部性原理

指令局部性原理与数据局部性原理，指指令执行或读写数据时，短期内大多数时间访问的都是周边的内容

#### Amdahl定律

$$
加速比 = \frac{整个任务在未升级时的执行时间}{整个任务在升级时的执行时间}
$$

Amdahl定律假设加速比取决于下列两个因素

* 原计算时间中可升级部分所占的比例
* 通过升级得到的改进

$$
新执行时间 = 原执行时间 * ((1-升级比例) + \frac{升级比例}{升级加速比})
$$

这里的意思即不能被升级部分的新执行时间保持不变，可升级部分的新执行时间为原时间除以加速比

## 第二章  存储器层次结构设计
