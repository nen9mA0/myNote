## 编写主引导扇区代码

### 主引导扇区

Main Boot Sector(MBR)  硬盘的**0面0磁道1扇区**

有**512字节，结尾为0x55 0xAA**，BIOS初始化后将其加载到**0000:7c00**执行

### 在屏幕上显示文字

#### 显卡和显存

8086显存地址：**0xB8000~0xBFFFF**，共0x8000字节

一般BIOS加电自检后会初始化图形模式为80\*25

#### 显示字符

在**字符模式**下，一个字符显示占用两个字节，第一个字节为ASCII码，第二个为显示属性

##### 显示属性

1字节

```
  背景色 | 前景色
   4b   |   4b
K R G B | I R G B
```

* K：闪烁位
* I：亮度位

#### 声明并初始化数据

标号 类型 数据

```
data db 0x11, 0x12
```

##### 类型

* db
* dw
* dd
* dq

#### 在末尾加0xAA55

```c
times 510-($-$$) db 0
                 db 0x55,0xaa
```

`$`为当前行的地址，`$$`

## 相同的功能不同的代码

### 处理器标志位

#### EFLAGS

```
15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
  |  |  |  |OF|DF|IF|TF|SF|ZF|  |AF|  |PF|  |CF
```

* OF  overflow
* DF  direct
* IF  中断允许
* TF  调试标志位
* SF  sign  符号
* ZF  zero
* AF  辅助进位（最后四位向前进位，用于BCD码计算
* PF  奇偶
* CF  进位

##### CF与OF

* CF  MSB进位，用于无符号数的溢出判断
* OF  被减数MSB异或结果MSB，用于有符号数的溢出判断

###### CF

进位/借位符号。当加法进位/减法借位时置1。用于判断无符号数是否溢出

无符号数的溢出场景

* 上溢  `A+B > 2^n-1`
* 下溢  `A-B < 0`

CF判断不仅仅是根据补码运算是否溢出  https://stackoverflow.com/questions/12237725/carry-flag-in-substraction

```asm
MOV AX, 5
MOV BX, 10
SUB AX, BX

MOV AX, 5
MOV BX, 10
NOT BX
INC BX
ADD AX, BX
```

上面的sub与下面的add看似运算上等价（上面是减去某数，下面是加上某数补码），但对于flag的影响不一样。sub运行后CF=1，add运行后CF=0

这是因为在X86处理器中，对于sub运算，**CF值会被取反**，即没有溢出时反而CF会置1，有溢出时置0。不同处理器在这点的处置上不同。但对于所有处理器，add指令执行时CF都不会被取反

这样做的理由是，对于add，无符号数只会上溢（即结果大于2^n-1），而对于sub，无符号数只会下溢（即结果小于0）。对于`A-B = A+(-B)`，当A>B时，补码运算将溢出，但此时实际上sub并没有下溢；相反当A<B时，将发生下溢，但补码运算并没有溢出。因此部分处理器对于add与sub的处理不同

###### OF

用于判断有符号数是否溢出。当数据超出有符号数表示范围时置位，如对于 0x70+0x70 ，OF置位而CF不置位

有符号数的溢出场景

**计算场景**

* $$
  A > 0, B > 0 \ \ A,B \in [0, 2^{n-1}-1]
  \\
  A+B \in [0,2^n-2]
  $$

* $$
  A < 0, B < 0 \ \ A,B \in [-2^{n-1}, -1]
  \\
  A+B \in [-2^n, -2]
  $$

* $$
  A > 0, B < 0 \ \ A \in [0, 2^{n-1}-1], \ \ B \in [-2^{n-1}, -1]
  \\
  A-B \in [1, 2^n-1]
  $$

* $$
  A < 0, B > 0 \ \ A \in [-2^{n-1}, -1] \ \ B \in [0, 2^{n-1}-1],
  \\
  A-B \in [-2^n-1, -1]
  $$

**对于8位数据**

* ```
  A,B in (0x00, 0x7F)
  A+B in (0x00, 0xFE)
  ```

* ```
  A,B in (0x80, 0xFF)
  A+B in (0x100, 0x1FE)
  ```

* ```
  A in (0x00, 0x7F)  B in (0x80, 0xFF)
  A-B in (0x01, 0xFF)
  ```

* ```
  A in (0x80, 0xFF)  B in (0x00, 0x7F)
  A-B in (0x101, 0x1FF)
  ```

**溢出情景**

|          | 正+正   | 负+负   | 正-负   | 负-正   |
| -------- | ------- | ------- | ------- | ------- |
| MSB(A)   | 0       | 1       | 0       | 1       |
| MSB(B)   | 0       | 1       | 1       | 0       |
| MSB(SUM) | 0  /  1 | 0  /  1 | 0  /  1 | 0  /  1 |
| OF       | 0  /  1 | 1  /  0 | 0  /  1 | 1  /  0 |

即，当sum的符号与预期不一致时，则为溢出

整理上面真值表，可得解析式`OF = MSB(A) xor MSB(SUM)`

#### 跳转条件

##### 条件表

| 指令      | 条件   | 描述                 |
| --------- | ------ | -------------------- |
| je / jz   | ZF = 1 | Equal / Zero         |
| jne / jnz | ZF = 0 | Not Equal / Not Zero |
|  **有符号数**  |                  |                         |
| jg / jnle | ZF = 0 && SF = OF    | Greater / Not Less or Equal |
| jge / jnl | SF = OF              | Greater or Equal / Not Less |
| jle / jng | ZF = 1 \|\| SF != OF | Less or Equal / Not Greater |
| jl / jnge | SF != OF             | Less / Not Greater or Equal |
| **无符号数** | ||
| ja / jnbe | CF = 0 && ZF = 0 | Above / Not Below or Equal |
| jnb / jae | CF = 0 | Not Below / Above or Equal |
| jbe / jna | CF = 1 \|\| ZF = 1 | Below or Equal / Not Above |
| jb / jnae | CF = 1 | Below / Not Above or Equal |
| jpe  | PF = 1 | Parity Even |
| jpo  | PF = 0 | Parity Odd |

##### 说明

首先A-B = A+(-B)，-B在计算机中即为B的补码

* 相等判断： cmp A,B 实际上执行的是A-B，若结果为0，即A=B，则ZF = 1
* 无符号数的比较，主要看CF位
  * 若A>B，A-B运算不溢出，因此CF=0，对应a（above）
  * 若A<B，A-B运算溢出，因此CF=1，对应b（below）
* 有符号数的比较，主要看OF位
  * 若A>B，A-B运算有两种情况
    * A B异号，A>0 B<0，可能溢出，溢出时SF=1，OF=1
    * A B同号， 由上述溢出情景可得，不可能溢出，OF=0，且因为A>B，所以对于A-B，SF=0
  * 若A<B，A-B运算有两种情况
    * A B异号，A<0 B>0，可能溢出，溢出时SF=0，OF=1
    * A B同号，不会溢出，OF=0，又因为A<B，所以A-B<0，SF=1

### 数据传送指令

`DS:SI -> ES:DI`

**movsb movsw**

#### rep

加上rep前缀后执行CX次

#### DF标志

* DF=0  每次rep后DI/SI +1
* DF=1  每次rep后DI/SI -1

**std**置1，**cld**清零

## 比高斯更快的计算

### 内存寻址

假设默认段寄存器DS为0x7c00

#### 直接寻址

使用立即数

```asm
mov ax, [0x5c0f]
```

地址为 0x7C000+0x5C0F=0x81C0F

#### 基址寻址

使用通用寄存器

```asm
mov ax, [bx]
```

#### 变址寻址

使用变址寄存器

```asm
mov ax, [si]
```

#### 基址变址寻址

使用基址寄存器+变址寄存器

```asm
mov ax, [bx+si]
```

## 硬盘和显卡的访问与控制

### IO端口访问

#### in和out

使用in和out指令。这两条指令都不影响标志位

#### 地址空间

对于部分计算机系统来说，端口地址空间是映射到内存地址空间的，例如0x00000~0xE0000是真实的物理内存地址，而0xE0001~0xFFFFF是映射的端口地址空间。因此对于这块内存的访问实际上是在访问端口

而另一部分计算机系统则是独立编址的

实际上in/out和mov指令的主要区别就在于CPU上的一个引脚 M/IO#（#表示低电平有效）。当进行正常的内存访问时，该引脚为高；运行访问IO的指令时（如in和out）引脚为低

### x86 16位模式的地址划分

![](pic/x86_3.png)

### 硬盘控制相关

#### 编址

最简单的方式是**CHS**，即磁头号、柱面号和扇区号。更好的方式是**逻辑扇区**，磁盘按某种顺序从0开始对磁盘的每个扇区进行编号，访问的时候不需要考虑磁头和柱面。

逻辑扇区的编码方式主要有LBA28和LBA48，前者使用28b来表示扇区号，因为一般一个扇区是512字节，因此可以管理 2^28 * 512 = 128G 的硬盘；而LBA48采用48b的地址，可以管理131072TB的容量。

#### 硬盘控制相关寄存器

IO地址 0x1F0~0x1F7

* 0x1F0  数据读写端口

* 0x1F1  错误寄存器

* 0x1F2  扇区号

* 0x1F3~0x1F5  LBA

  * 0x1F3  0~7
  * 0x1F4  8~15
  * 0x1F5  16~23

* 0x1F6  如图

  * 0~3位：LBA 24~27
  * 第4位：0：代表主盘  1：代表从盘
  * 5~7位： 111：代表LBA模式   101：代表CHS模式

  ![](pic/x86_1.png)

* 0x1F7  值0x20表示硬盘读。其他位如图

  ![](pic/x86_2.png)

硬盘读取函数代码见[这个文件](x86_program/common/common.asm)的read_disk函数 demo见[这个文件](x86_program/08/read_disk.asm)

### 加载器的一些细节

本章写的加载器代码见[这个文件](x86_program/08/bin_loader.asm)

#### 程序头

注意，程序头的定义如下

```
00	dd		程序长度
; ==== 入口点 ====
04	dw		入口点偏移
06	dd		入口点段地址
; ==== 重定位表 ====
0A	dw		重定位表项个数
;	==== 重定位表项 ====
0C+0	dd	每个表项都是该段对应的段地址
0C+4	dd
	...
```

其中，入口点段地址是入口点所在的segment相对应用程序文件的偏移量，而并不是其需要加载到的绝对地址。文件加载到哪个地址最终还是由加载器确定

#### 加载器工作流程

* 在要加载程序的地址先读入应用程序的一个扇区数据

* 解析程序头的程序长度信息，读入剩余的扇区数据（load_bin函数中）

* 根据加载地址对入口点段地址和重定位表项的段地址进行调整。这里的细节如下

  * 重定位表项记录的其实是每个段在文件中相对文件头的偏移，此外每个段都是16字节对齐的

    因此假设程序的加载地址是0x10000，某个段A的偏移是0xA0，那么加载后的地址应该是0x100A0，应该讲重定位表项的值修改为0x100A（重定位表项的值是直接赋给段寄存器的值）

    此外，这里修改重定位表项后，段地址是写到表项的**低位**，因为段地址只能有16位。一样如上例，段A偏移是0xA0，因此对应的表项应该是 00A0 0000（低位在低地址），而修改后应该为 10A0 0000

### 显卡控制相关

显卡的寄存器很多，为了减少占用主机的IO空间，很多寄存器只能通过索引寄存器间接访问

* 0x3d4  索引寄存器
  * 索引14  光标位置高8位
  * 索引15  光标位置低8位
* 0x3d5  数据端口  用于与索引寄存器指定的寄存器通信

### 滚动显示程序的一些细节

#### putchar函数

几个关键要考虑的内容

* 0x0a（换行）的处理
* 0x0d（回车）的处理
* 滚动显示：当显示的字符大于2000（80*25）时，将2~25行的整体上移80个字节（一行为80字节）



## 附录

### 系统调用表

