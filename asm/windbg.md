https://www.52pojie.cn/thread-924116-1-1.html

## 标准命令

### t 单步步入 /p 单步步过

```
p|t [r] [=StartAddress] [count] ["Command"]
```

- r表示禁止显示寄存器内容
- 默认情况下，调试器总是让目标从当前位置开始单步执行，但是也可以通过等号(=)来指定一个新的起始地址，让程序从这个地址开始单步
- count用来指定单步执行的次数
- Command用来指定每次单步执行后要执行的命令

#### 实例

```
tr =77e40d8e 2 "kb"
```

从0x77e40d8e开始执行单步， 单步2次，不显示寄存器内容，每次单步执行完后执行kb

### pa ta 单步执行到指定地址

```
pa|ta [r] [=StartAddress] StopAddress
```

- pa是Step To Address的缩写，即单步执行到StopAddress参数所代表的地址处
- pa和ta的区别在于 ta在遇到函数时会进入函数，windbg的执行结果会显示函数内容；而pa则是直接步过函数，windbg的执行结果不显示函数内容

### pc tc 单步执行到下一个函数（call）

```
pc|tc [r] [=StratAddress] [Count]
```

- pc或tc命令都是让调试目标从当前地址或者StartAddress指定的地址恢复执行，直到遇到函数调用时停下来
- Count用来指定遇到的函数调用指令个数
- 这两个的差别依然是在进入和不进入函数时windbg显示的结果上有区别

### tb 单步执行到下一个分支

```
tb [r] [=StartAddress] [Count]
```

不能在x86的用户态模式下使用

### g 继续运行

```
g[a][=StartAddress] [BreakAddress][;BreakCommands]
```

- 其实StartAddress用来指定开始执行的起始地址 这个功能有点像OD的此处为新的EIP
- BreakAddress用来指定一个断点地址
- BreakCommands用来指定断点命中后所指定命令
- 如果不带任何参数，那么g命令就是恢复目标运行 相当于OD的F9
- 可以用gu命令来执行到返回 相当于OD的Ctrl+F9

### gu 执行到返回

如上

### wt 追踪并监视

**在call的第一条指令处使用**，表示统计该函数的内容，如下

- 第一个部分是标题 显示了追踪的函数名和追踪的结束地址
- 第二部分是详细的执行情况 包括如下四列：
- 第一列为指令数，这一列的数字就是这个函数从入口进入到下一行所对应的函数入口所执行的指令
- 第二列用来显示本行所对应的函数调用其他函数时所执行的总指令数
- 第三列表示函数的调用深度 没进入一个函数深度加一
- 第四列为函数名称 名称前的缩进用来表示深度

### u 反汇编

### q 停止调试

### k 栈相关指令

L选项可以与下面任意指令组合，这样将不显示函数所属模块的位置

#### k

- 其中的每一行代表栈上的一个栈帧 也就是一个函数
- 最上面一行表示的是当前正在执行的函数 每个函数下面一行是上一行的父函数
- 第一列是栈帧的基地址EBP
- 第二列是函数的返回地址
- 第三列是函数名以及执行位置

#### kb 

显示函数在栈上的前三个参数

#### kp

显示函数原型、参数、参数值，需要有符号表

#### kv

在kb基础上增加显示FPO信息和调用约定

#### kn

在每行前显示栈帧序号

### d 显示内存

#### d

```
d{a|b|c|d|D|f|p|q|u|w|W} [Options] [Range]
```

- a表示ASCII码
- b表示字节和ASCII码
- c表示DWORD和ASCII码
- d表示DWORD
- D表示双精度浮点数
- f表示单精度浮点数
- p表示按指针宽度显示
- q表示四字（8字节）
- u表示UNICODE字符
- w表示字
- W表示字和ASCII码
- yb表示二进制和字节
- yd表示二进制和双字

range格式：

- 第一种方法是起始地址加空格加终止地址，比如dd 0012fd9c 0012fda8命令以双字格式显示从0012fd9c开始到0012fda8结束的16字节内存数据
- 第二种方法是起始地址加空格加L（或者1）和对象个数，比如上面的命令可以等价的写为：dd 0012fd9c L4
- 第三种方式是结束地址加空格加L（或者1）加负号和对象个数。使用这种方式可以把上面的命令写为：dd 0012fdac L-4

#### du

是上面d指令的一种用法，显示字符串

```
du addr
```

#### dt 显示数据类型

```
dt[模块名!]类型名
```

若模块名忽略，则搜索全部模块

* -b   递归显示子类型
* -rn  若递归显示，则n指定递归层数
* -ny name  字段搜索，仅显示name字段内容

##### 实例

###### 用法1 搜索数据类型

```
dt ntdll!*		列出ntdll的所有类型，用-b开关递归显示子类型（若类型还包含子类型的成员）
dt -r1 _TEB
dt _TEB -ny LastError
```

###### 用法2 按照指定格式显示内存值

```
dt _PEB 7ffdd000	按照_PEB类型显示0x7ffdd000的数据
```

###### 用法3 按照类型的实例

```
dt dbgee!*wmain*	显示dbgee程序的wmain变量
```

### s 搜索内存

#### 用法1 在内存范围内搜索ASCII或UNICODE字符串

```
s-[[Flags]]sa|su Range
```

- Range用来指定内存范围
- sa用来搜索ASCII字符串 su用来搜索unicode字符串
- Flag可以指定搜索选项

##### 实例

```
s-[l5]sa poi(nt!)PsInitialSystemProcessl200			搜索nt!PsInitialSystemProcess变量所指向地址开始的512个字节范围内任何长度不小于5的ASCIⅡ字符串
```

#### 用法2 在指定内存地址范围内搜索与指定对象相同的对象

```
s[[Flags]]v Range Object
```

#### 用法3 在指定范围内搜索某一内容模式

```
s[-[[Flags]]Type] Range Pattern
```

- 其中类型表示搜索的内容的数据类型(宽度)，可以为b(字节) d(双字)
- Pattern参数用来指定要搜索的内容

##### 实例

```
s 0012ff40 L20 'H' 'e' 'l' 'l' 'o' 
s 0012ff40 L20 48 65 6c 6c 6f 
s -a 0012ff40 L20 "Hello" 
```

都是在0012ff40的0x20个字节内搜索Hello

### e 修改内存

#### 用法1 按字符串编辑

```
e{a|u|za|zu}Address "String"
```

- 其中Address是要修改的内存的起始地址
- za代表以0结尾的ASCII字符 zu代表以0结尾的Unicode字符
- a和u分别代表不是以0结尾的ASCII和Unicode字符

#### 用法2 按数值编辑

```
e{b|d|D|f|p|q|w} Address [Values]
```

- 其中大括号中的字母用来表示要修改的数据类型，也决定要修改的内存方式
- Address用来指定要修改的内存起始地址
- Values用来指定新的值

##### 实例

```
Eb 00100000 01 02 03 04      数据类型为BYTE
Ed 00100000 0201 0403        数据类型为DWORD
Ea 00100000 ‘hello’          数据类型为ASCII
Eu 00100000 ‘你好’            数据类型为UNICODE
```

### r 查看或修改寄存器

### lm 显示加载的模块

loaded module

## 元命令

### .attach

`.attach PID`

### .detach

分离调试器

### .restart

重启被调试应用

### .cls

清屏

### .format

显示数字的各种格式信息

### .reboot

重启虚拟机

### .help

## 扩展命令

## 伪寄存器

| 伪寄存器  | 含义                                     |
| :-------- | :--------------------------------------- |
| $ea       | 调试目标所执行上一条指令的有效地址       |
| $ea2      | 调试目标所执行上一条指令的第二个有效地址 |
| $exp      | 表达式评估器所评估的上一条表达式         |
| $ra       | 当前函数的返回地址                       |
| $eip      | 指令指针寄存器                           |
| $eventip  | 当前调试事件发生时的指令指针             |
| $previp   | 上一事件的指令指针                       |
| $relip    | 与当前事件关联的指令指针                 |
| $scopeip  | 当前上下文的指令指针                     |
| $exentry  | 当前进程的入口地址                       |
| $retreg   | 首要的函数返回值寄存器                   |
| $retreg64 | 64位格式的首要函数返回寄存器             |
| $csp      | 栈顶指针ESP                              |
| $p        | 上一个内存显示命令所打印的第一个值       |
| $proc     | 当前进程EPROCESS结构的指针               |
| $thread   | 当前线程ETHREAD结构的指针                |
| $peb      | 当前进程的进程环境块(PEB)的地址          |
| $teb      | 当前线程的线程环境块(TEB)地址            |
| $tpid     | 拥有当前线程的进程ID(PID)                |
| $tid      | 当前线程的线程ID                         |
| $bpx      | X号断点的地址                            |
| $frame    | 当前栈帧的序号                           |
| $dbgtime  | 当前时间                                 |
| $callret  | 使用.call命令调用的上一个函数的返回值    |
| $ptrsize  | 调试目标所在系统的指针类型宽度           |
| $pagesize | 调试目标所在的系统的内存页字节数         |