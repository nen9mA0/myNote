### 研究对象

常规的内存分配器，即程序可以在任何时候申请一块内存以存放对象，也可以在任何时候释放该内存

该文章假设当一块内存被分配时，其内容无法被直接移动到一个新的内存地址，因为内存管理器无法获知程序中哪些地方使用到了先前内存块的指针。此外内存管理器并不关心内存的内容，而只关心分配请求的大小。

文章也假设对内存各部分的访问速度是均匀的，即不考虑访问地址带来的影响。

此外该文假设程序对申请的对象进行压缩等操作也与分配器算法本身无关，而是程序自身的行为。并行的分配器也不在讨论范围。

文章认为设计分配器算法的主要优化目标应该是减少内存使用量，而非减少时间复杂度。因为后者由于不同情况下的分配策略不同，可能难以衡量复杂度，相反衡量前者较为容易。且文章认为一个空间复杂度低的分配器算法时间复杂度也相应较低。

### 章节简介

* 第一章  概述
* 第二章  更深入地探讨内存碎片化，与相应的优化方法
* 第三章  目前常见内存分配器的分类
* 第四章  回顾主流的关于内存分配器的研究
* 第五章  总结

### 第一章 概述

#### 分配器应该做什么

* 跟踪所有分配出去的和空闲的内存
* 使用尽量少的额外空间和额外时间来管理内存
* 应及时对程序的内存申请和释放请求进行响应
* 不能对当前被占用的块进行压缩、移动、改变其大小等操作

#### 内存分配器面临的主要问题

* 用户程序可能以任意顺序申请和释放内存块，使得原本连续的地址空间被切割成多个空闲块和占用块交替的空间，即碎片化。过度碎片化会使得分配器在内存总量够用的情况下却无法响应对于大内存的申请（因为虽然总量够但是被切分成多块，没有连续的空间）

#### strategy, policy and mechanism

上述几个内存分配器术语的解释如下

* strategy:  一般指利用请求流中的规律性制定的规则
* policy:  一般指块在内存中分布的规则
* mechanism  用于实现policy的一系列算法与数据结构

### 第二章 内存碎片化

#### 内部碎片化与外部碎片化

内部碎片化指程序被分配到比申请的数量大的内存块

外部碎片化指当内存块被释放，但无法被合并的情况下，可能导致这块内存无法被再次分配（当请求数总是大于这块内存时）

#### 随机模拟

一种传统的评估分配器算法的方法，即随机产生一系列分配请求，其分配大小与存活时间符合某种分布。在运行一段时间后，理论上分配器将达到稳态，对此时的分配器运行情况进行评估。

一般有三种常见的生成随机模拟的方法

* 使用一个简单的数学函数来随机产生分配大小和存活时间，一般这两者的分布满足均匀分布或指数分布（因为一般来说程序会较频繁地分配空间小、存活时间短的块）
* 将程序的各种行为任意组合，来模拟一个程序实际运行的效果
* 统计某些程序运行时对内存的分配和释放记录，作为分配器输入。这种方法更加贴合实际运行的情况。

此外，使用均匀分布或平滑分布来进行测试可能有些问题，因为这种分布几乎总会使分配器分配大小不同的内存，这种情况很容易导致内存碎片化，即会使分配器展现出相较于大多数运行环境下要差一些的结果

### 参考文献

[Wil95]  copying garbage collectors

[Rob71 GGU72 Rob74 Rob77]  证明无论什么分配器算法策略，都会有一些场景使其面临严重碎片化的问题
