## 进程

### 进程介绍

#### 进程模型

```
----- Running -----
| 1          ^     | 2
v            | 3   v
Blocked ----> Ready
          4
```

* Running -> Blocked   遇到IO操作 sleep等阻塞操作
* Running -> Ready      进程时间片切换
* Ready    -> Running   进程被重新调度
* Blocked  -> Ready      进程所要求的IO操作被完成

#### 进程实现

存储一个结构体记录每个进程的数据，包括

```
通用寄存器
pc
psw
栈指针
进程状态
进程开始时间
已使用CPU时间
children's CPU time(没懂指什么，子进程？)
下次alarm的时间
消息队列指针
Pending signal bits(信号阻塞位)
pid
其他flag bits
```

最简单的通过中断的进程切换过程

* pc压栈
* 从IVT读取新的pc
* 保存上下文
* 装入新栈指针
* 执行中断服务程序(Scheduler)
* Scheduler更新原进程状态
* Scheduler选取下一个执行的进程
* 装入新上下文
* 执行新进程

#### 线程

线程的实现可以在内核中也可以在用户代码中，但需考虑下面问题

* 对于只在内核实现的线程，调度效率可能很低，并且若操作系统以与进程相同的方式调度内存则可下次调度可能是不同进程的线程，也可能是同一个进程的线程，导致效率急剧下降
* 对于只在用户空间实现的线程，因为操作系统并不知道线程的存在，可能出现当一个线程阻塞时，整个进程都被阻塞的情况

因此一般采用混合的模式

此外还有下列问题需要考虑

* 对于fork
  * 若父进程有多个线程，子进程是否继承
  * 若父进程单个线程阻塞，子进程fork后会不会出现两个进程的对应线程都阻塞在同一个地方的情况
  * 上述问题在资源共享，网络连接时的情况
* 一个线程在读文件另一个线程想关闭文件
* 旧线程发现内存不够要申请，此时发生切换，新线程也发现内存不够，会不会申请2份
* 函数可重入性
* 错误报告：线程1进行了系统调用，读取前发生切换，线程2也执行了系统调用将errno的值刷新
* 线程与信号机制协同运作
  * 线程库需要负责信号的申请 接收与分配
  * 单个进程只能调用一个alarm，若有多线程调用alarm的情况则可能产生问题
* 堆栈
  * 当堆栈大小不够时，操作系统会分配新的堆栈空间。但对于多线程需要有多个堆栈，因此操作系统无法获知这些堆栈的情况（因为由用户管理的线程对于操作系统是透明的），就无法分配新堆栈，导致堆栈溢出

### 进程间通信

#### 条件竞争

进程A和B共享一个服务，假设是个打印服务，正常流程是进程获取打印队列计数n，往队列第n个槽位写入要打印的文件，n = n+1

A要打印文件，于是先读入打印队列计数n。此时发生进程切换，B也要打印文件，于是读入打印队列计数n，往队列第n个槽位写入要打印的文件，n = n+1。进程再切换回A时，A并不知道n被刷新，因此还是会往n的位置写入要打印的文件（本应是第n+1的位置）

#### 临界区

把对共享内存进行访问的程序片段称为临界区

设计的思路就是让临界区代码互斥，具体应满足下列要求

* 任何两个进程不能同时处于临界区
* 不应对CPU的速度和数目作任何假设
* 临界区外的进程不得阻塞其他进程
* 不得使进程在临界区外无休止地等待

![](pic\process_1.png)

#### 使用忙信号互斥

##### 关中断

最简单的方法就是关中断，但这种方法应该是操作系统层面使用的，即操作系统在处理某些共享数据时把中断关闭防止中断突然到来导致条件竞争。对于用户程序不应允许其关闭中断

##### 锁变量

设想一个共享的变量作为锁，一个进程进入临界区时将其置1，其他进程进入前先判断锁的值，若为1则阻塞

但单纯的一个锁变量可能导致问题，即进程A进入临界区后，还未把锁置0就发生了进程切换

##### 严格轮换

```c
//Process A
while(true)
{
    while(turn != 0);
   	critical_region();
    turn = 1;
    noncritical_region();
}

//Process B
while(true)
{
    while(turn != 1);
   	critical_region();
    turn = 0;
    noncritical_region();
}
```

这种方案严格地让A B进程轮流进入临界区，但也只能轮流进入。违背了临界区设计规则的第三条：不能让进程在临界区外无限等待。

##### Peterson方案

综合了严格轮换和锁的方法，但存在需要花大量时间死循环阻塞在忙状态的问题

```c
int turn;
int interested[2];

void enter_region(int pid)
{
    int other = 1 - pid;	//when pid=1 other=0  when pid=0 other=1
    interested[pid] = true;
    turn = pid;
    while(turn == process && interested[other] == true);
}

void leave_region(int pid)
{
    intereseted[pid] = false;
}
```

##### TSL指令

用硬件支持的锁指令实现上锁，同样在忙状态死循环阻塞

tsl指令同时完成将lock处的值拷贝到寄存器与将lock处的值置1两个操作

```asm
enter_region:
	tsl register, lock
	cmp register, #0
	jne enter_region
	ret
	
leave_region:
	mov lock, #0
	ret
```

#### 睡眠和唤醒

死循环阻塞在忙状态可能导致**优先级翻转问题**

即，当进程A优先级高于B，但B已进入临界区，而A阻塞在临界区。但此时因为A优先级高，所以调度器不会调度B执行，导致死锁

##### 生产者-消费者问题

n个生产者往缓冲区写数据，m个消费者从缓冲区读数据

基本思想：生产者写数据，若缓冲区满，自己休眠；若缓冲区数据数量由0增加到1，则唤醒消费者。消费者读数据，直到缓冲区空，自己休眠；若缓冲区数据数量由N减少到N-1，则唤醒生产者

这样，若生产者产生数据速度大于消费者读取速度，则直到缓冲区满将睡眠，并在消费者读完缓冲区第一个数据时被唤醒。若生产者产生数据速度小于消费者读取速度，则消费者读到缓冲区空将睡眠，并在生产者产生下一个数据后被唤醒

```c
#define N 100
int count = 0;

void producer(void)
{
    while(true)
    {
        produce_item();
        if(count == N)
            sleep();
        enter_item();
        count += 1;
        if(count == 1)
            wakeup(consumer);
    }
}

void consumer(void)
{
    while(true)
    {
        if(count == 0)
       		sleep();
        remove_item();
        count = count - 1;
        if(count == N-1)
            wakeup(producer);
        consume_item();
    }
}
```

**条件竞争**：若consumer读取count时为0，此时进程切换到producer，producer生产了一份数据并唤醒consumer，但consumer实际并未睡眠，因此wakeup信号将丢失。此时进程切换回consumer，consumer仍认为count=0，因此将睡眠。而之前用于唤醒这次睡眠的信号已经丢失，因此consumer将一直睡眠，而producer因为产生数据后没人读取因此最后也会进入睡眠。

一个解决方案：设置一个唤醒等待位，当向清醒进程发送wakeup时将置位，但每个进程都必须有一个唤醒等待位

#### 信号量

信号量提供UP（V）和DOWN（P）两种操作，两种操作均是原子操作

V操作对应WAKEUP，P操作对应SLEEP

即，当有进程sleep时，信号量-1，有进程被wakeup时，信号量+1