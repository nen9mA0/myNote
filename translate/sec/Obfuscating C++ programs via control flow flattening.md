# OBFUSCATING C++ PROGRAMS VIA CONTROL FLOW FLATTENING

## 摘要

保护软件不被越权读取是一项艰巨的任务。在这篇文章中，我们着重于通过混淆的方式保护源代码，并且讨论

一种用于C++语言控制流转化的名为控制流平坦化的技术。此外文章对于上述的方法提出了一个具体的实现算法。

对于原型算法的测试表明经过混淆处理的程序的复杂度将是原程序的5倍。

## 1.介绍

​        保护软件不被越权读取是一项艰巨的任务。不幸的是，保证软件完全安全是不可能的，只要有足够的时间，没有不能被破解的代码。因此，保护的目的在于使分析工作变得更难。

​        系统可以在不同的层面上被保护，如：硬件层，操作系统层或源代码层。在这篇文章里我们着重于使用混淆技术保护源码。现在已经有许多代码混淆技术，他们的共同特点修改代码使其难以理解，且保持原有的功能。最简单的技术是layout transformation，它去除代码里的变量名，去除注释和调试信息。另一类技术是数据混淆，它改变数据结构，例如：改变变量可见性或重新布局数组的内存结构。第三类技术为控制流转化算法，目的是向分析工具隐藏程序的控制流。这些算法将原程序的控制结构转换成等价但更为复杂的代码，插入不相关的代码或使控制流平坦化。

​        在这篇文章中，我们讨论一种名为控制流平坦化的控制流转化技术，用于混淆C++代码。虽然主要思想已经在[3]中被描述，但还未有关于特定语言的实现技术的文章被发表。这篇文章主要贡献如下：

* 我们发现了控制流平坦化技术在C++语言实现上的问题并给出了解决方案
* 我们给出了完整的实现算法
* 使用上述实现算法我们展示了算法对测试程序的使用效果

文章以如下方式组织。第二节具体描述了在C++里实现控制流平坦化技术存在的具体问题，并且提供了解决方案。此外，我们给出了具体算法。第三节里展示了算法的效果。第四节我们列出了相关的研究。第五节汇总结果并给出结论。

## 2.C++程序的控制流平坦化

​        对于大多数实用的程序，由于高级语言的代码构建方法和程序员的编码习惯，分支和跳转的目标都能很容易被识别。在这种情况下，一个函数的控制流复杂度与它的基础控制块的数量线性相关。控制流平坦化的基本思想就是将源码中的控制结构转化，使程序的目标分支不易被静态分析，从而阻碍逆向分析者对程序的理解。

​        平坦化一个函数控制流的基本方法如下：首先，将函数体划分为一些基本块，然后将所有这些原本在不同嵌套层次中的块平行放置。随后将这些基本块封装进同一个选择结构中（C++中的switch语句），不同的case对应不同的基本块，且选择结构被封装在一个循环中。最后，控制流程的选择由一个表示程序当前状态的变量指定，这个变量在每个基本块的最后被设定，从而指定下一次循环运行的基本块。图1给出了该方法的一个例子。原程序与混淆后的控制流图展示了程序结构上的改变：所有语句块在同一个嵌套层次中，从而隐藏了原程序里的循环结构。

![图1  控制流平坦化对于源码的影响(a:原程序 b:平坦化后的程序) 和对于控制流图的影响(c:原程序 d:平坦化后的程序)](pic\obfuscating\1.png)

### 2.1 C++实现中的问题

​        根据上面的描述，控制流平坦化的功能似乎很简单。但当我们想在实际程序中使用时会遇到一些问题。下面我们将讨论一些在C++中实现控制流平坦化技术可能遇到的困难。

​        根据图1所示的示例，将循环拆分为基本块不是简单地将循环的头部与循环体分开。如果保持原有的循环结构（while，do，for），将使平坦化后的代码结果错误。因为单个循环头部与循环体拆分执行的行为与原来的行为不相同。因此，对于循环，头部应使用与原循环头部语义相同的if语句替换。且应为流程控制变量分配合适的值使其正确执行控制流。

​        另一个处理起来较为琐碎的复合语句是switch。导致问题的原因是switch较不严格的的语法规范：switch的控制语句可以是任何符合语法规定的语句，且所有case标签中的内容可以是任何子控制块的一部分。一个展示改特性的例子是Duff's device[10]，对这段代码中循环的展开方式是将其转化为一个switch和一个循环的形式。一个可能的源码及其平坦化后的代码如图二所示。

![图二  Duff's device (a:原程序  b:平坦化后的程序)](pic\obfuscating\2.png)

​        当遇到循环和switch语句时，我们就必须讨论循环控制语句（break、continue），若直接将循环控制语句放入平坦化后的程序，break和continue将导致问题，因为这些语句将影响平坦化后的控制循环。为了避免其影响控制循环，这些语句需要被替换成对流程控制变量的赋值语句。图三展示了一个例子。

![图三 对于循环控制语句的转化(a:原程序 b:平坦化后的程序)](pic\Obfuscating\3.png)

​        与C相比，C++引入了新的控制语句：用于错误处理的try-catch结构。如果简单地将其作为语句块放入switch的一个case标签中将破坏原有的错误处理逻辑。在这种情况下，被从try块中分离出去的语句块将不会被错误处理机制所保护，其抛出的异常也不会被原本的错误处理函数捕获。为了在平坦化后的程序中保持与原程序相同的行为，每一个try-catch块中的语句都会单独生成一个while-switch控制结构，且该控制结构被对应try-catch块所包裹。因此，对于try结构的控制流平坦化将产生多个嵌套的平坦化代码块。当try块中包含循环控制语句时这又将导致在不同嵌套的平坦化代码块中转移的问题。

​        图四展示了一个由try块生成的多个嵌套的平坦化代码块，也展示了由break导致的不同嵌套的代码块跳转的解决方案，虽然goto语句不被编码规范所提倡，但在此处使用goto是较为合适的。

![图四 带有循环控制语句的错误处理代码(a:原程序 b:平坦化后的程序)](pic\Obfuscating\4.png)

### 2.2 控制流平坦化算法

​        下面，我们将给出一个用于平坦化C++函数控制流的算法，且解决上一章所描述的问题。这个算法要求被平坦化的函数的语法树可用，且在预处理过程后，语法树被算法一次遍历，并生成混淆版本的代码。

​        算法的正式描述见图5,6,7，黑体字表示伪代码的关键字，roman字体的部分表示算法的标准化描述，italic字体的部分表示一些用文字描述较易理解的部分。算法的输出为C++代码，使用typewriter字体和双引号来标记。算法中有两个常用的符号：⊕ 表示字符串相加  => 表示输出算法的结果，可输出到控制台或文件。

​        算法从函数*control_flow_flattening*开始，这个函数执行一些对被处理函数的预处理，见图5

![图5 控制流平坦化算法 第一部分](pic\Obfuscating\5.png)

在这一步中，所有不在函数开头定义的变量（如被其他代码块引用的变量）都被移动到函数开头，这样做可以防止出现一些因变量作用域而导致的变量可见性的问题。而对变量的初始化操作保留在原来的位置。并且用一些变量重命名的方式解决名字冲突问题。

​        虽然把变量声明移动到函数开头是一个很重要的话题，它的复杂性[12]和本篇文章的篇幅所限使我们无法在文章中给出一个正式的解决方案。因此，下面我们假设预处理步骤成功执行且所有的变量声明在函数中都是唯一的。

​        真正的平坦化处理从函数*flatten_block*开始，在这个函数中生成被处理函数的控制流。如图4，在之前的章节中有些地方需要在不同嵌套的平坦化代码块中跳转。为了实现这点，控制流主循环使用一个标签来标记，每次当一个新的嵌套层次建立时，该标签与代码块中的变量被压入栈中。

​        *flatten_block*中调用的函数*transform_block*用于拆分由复合语句和简单语句组成的代码块，其他的*transform*系列函数根据语句类型对其进行混淆。*transform_if*函数（见图6）是一个拆分复合语句的例子：一个新的case标签被添加到switch语句中，对于if语句块内的语句递归调用*transform_block*。*transform_while*函数类似，但其在递归调用*transform_block*函数前，两个为执行break或continue语句准备的标签被分别压入*breaks*与*continues*栈。

![](pic\obfuscating\6.png)

![](pic\obfuscating\7.png)