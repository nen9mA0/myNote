# 龙书

## 一个简单的语法制导翻译器

### 上下文无关文法

#### 定义

四元素

* 终结符号集合（词法单元），指该文法所定义语言的基本符号集合
* 非终结符号集合（语法变量）
* 产生式集合
* 指定一个非终结符号作为开始符号

空串（0个终结符号组成的串）记为ε

##### 例1

加减表达式

```
产生式
list -> list + digit
list -> list - digit
list -> digit
digit -> 0|1|2|3|4|5|6|7|8|9
可以等价为：
list -> list+digit | list-digit | digit
digit -> 0|1|2|3|4|5|6|7|8|9
```

终结符号： 0 1 2 3 4 5 6 7 8 9 + -

非终结符号： list digit

#### 推导

从开始符号出发，不断将某个非终结符号替换为该非终结符号的某个产生式，则可以**从开始符号推导得到的所有终结符号串集合**称为该文法定义的语言

##### 例2

由上产生式推导 9-5+2

```
9:digit	由list->digit知 9:list
5:digit	由list->list-digit知 9-5:list
2:digit	由list->list+digit知 9-5+2:list
```

##### 例3

函数调用参数列表，可能有多个参数也可能无参数

```
call -> id(optparams)
optparams -> params|ε			可以为空
params -> params,param | param	可以为多个
```

#### 语法分析树

##### 性质

* 根节点为开始符号
* 每个叶子节点为终结符号或ε
* 每个内部节点为非终结符号

##### 例4

构造例2的语法分析树

```
	  			  list
	  list					digit
list		digit
digit
 9		-	 5		+		2
```

#### 运算符结合性

* 左结合 （以下以=为例）

```
right -> letter = right | letter
letter -> a|b|c
```

a=b=c语法树

```
	right
				right
letter		letter		right
a	=		b	=		c
```

* 右结合  如例1即为右结合

#### 运算符优先级

有n个优先级的语法需要n+1个非终结符号，高优先级的产生式在低优先级产生式的下方

##### 例5

以+ - * \为例，高优先级运算写在下面

```
expr -> expr + term | expr - term | term
term -> term * factor | term / factor | factor
factor -> digit | (expr)
```

#### 练习

##### 1

* s -> sS* -> sa* -> sS+ a* -> sa+ a* -> aa+ a*

* ```
  	S
    S   S *
  S S +
  a a + a *
  ```

##### 4

* S -> S S op | num

* S -> ,S | ε

* S -> S, | ε

* ```
  expr-> s+s | s-s | s
  s	-> factor*factor | factor/factor | factor
  factor -> id | num | (expr)
  ```

* ```
  expr-> s+s | s-s | s
  s	-> factor*factor | factor/factor | factor
  factor -> +tmp | -tmp | tmp
  tmp -> id | num | (expr)
  ```

##### 5

* ```
  生成式的对应操作为
  num = 3
  num = 9
  num = num * 2
  num = num * num
  所以都可以被3整除
  ```

### 语法制导翻译

将表达式**根据语义规则翻译**，其中**语义规则由产生式确定**

如将表达式翻译成后缀形式，其中t为表达式的**综合属性**，|| 表示字符串连接

一个语法翻译器例子见**语法分析-尾递归**

```
产生式					语义规则
expr -> expr+term		expr.t = expr.t || term.t || '+'
expr -> expr-term		expr.t = expr.t || term.t || '-'
expr -> term			expr.t = term.t
term -> 0				term.t = 0
...						...
term -> 9				term.t = 9
```

##### 例1

对于 9-5+2 的语法分析树

```
        expr
   expr       term
expr   term
term
9   -   5   +   2
```

因此对应的语法翻译树

```
                             expr.t=95-2+
         expr.t=95-                         term.t=2
expr.t=9          term.t=5
term.t=9
9           -          5          +           2
```

可以看到可以使用**自底向上的方法**遍历树，即可一次得到翻译结果，因为上一层的翻译结果仅依赖于该层各结点的结果

当语义规则仅包含**综合属性**时可以使用自底向上方法，但若包含**继承属性**则不行

#### 练习

##### 1

```
产生式					语义规则
expr -> expr+term		expr.t = '+' || expr.t || term.t
expr -> expr-term		expr.t = '-' || expr.t || term.t
expr -> term			expr.t = term.t
term -> 0				term.t = 0
...						...
term -> 9				term.t = 9
```

##### 2

```
产生式					语义规则
expr -> expr term +		expr.t = expr.t || '+' || term.t
expr -> expr term -		expr.t = expr.t || '-' || term.t
expr -> term			expr.t = term.t
term -> 0				term.t = 0
...						...
term -> 9				term.t = 9

翻译树
              expr.t
    expr.t             term.t
expr.t   term.t
term.t
9         5       -      2      *
```

### 语法分析

#### 自顶向下方法

![](I:\Git\Note\compiler\dragon_asset\2_4_1.png)

stmt为一个**非终结符号**，箭头指向**向前看符号**，指向当前要解析的符号

当向前看符号执行stmt时，对stmt的分析树进行展开，并选取**最左**的结点进行翻译，并反复执行该过程直到文件末尾

如上图，因为for和(都是终结符，因此向前看符号下一次将指向optexpr，但待翻译内容为空，则**第一个optexpr将赋值为ε**，而第二个和第三个将根据optexpr的展开对expr进行翻译

#### 左递归

在**预测语法分析器**中，当产生式**右边的第一项**与产生式左边相同时，会出现左递归问题

如 expr -> expr + term ，由于解释时将会按照expr展开，而expr展开后的第一个符号又是expr，因此将无限展开下去

##### 消除：

```
若原表达式为：
A -> Aa | b
替换为
A -> bA'
A'-> aA' | ε
```

例：

```
expr -> expr + term | term
则可以替换为
expr -> term A'
A' -> +term A' | ε
因为expr实际得到的结果为 term + term + ...
因此是相同的
```

#### 尾递归

对于语法翻译器中，如对于如下情况

```
expr -> term rest
rest -> + term {print('+')} rest
		| - term {print('-')} rest
		| ε
term -> 0 {print('0')}
		| 1 {print('1')}
		...
		| 9 {print('9')}
```

可以对应**语法制导翻译器**如下

其中lookahead为向前看符号

```c
void expr()
{
    term(); rest();
}

void rest()
{
    if(lookahead == '+')
    {
        match('+'); term(); print('+'); rest();
    }
    else if(lookahead == '-')
    {
        match('-'); term(); print('-'); rest();
    }
    else{}
}

void term()
{
    if( isnum(lookahead) )
    {
        t = lookahead; match(lookahead); print(t);
    }
    else report_err();
}

void match(terminal t)
{
    if(lookahead == t)
        lookahead = nextTerminal;
    else
        report_err();
}
```

对于rest()的最后一个函数调用为递归调用rest的情况，相当于跳到函数开头，因此可以用循环来优化

```c
void rest()
{
    while(true)
    {
        if(lookahead == '+')
        {
            match('+'); term(); print('+');
        }
        else if(lookahead == '-')
        {
            match('-'); term(); print('-');
        }
        else
        	break;
    }
}
```

### 词法分析



