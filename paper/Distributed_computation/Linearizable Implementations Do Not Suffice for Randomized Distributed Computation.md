### 例子

假设n个进程的快照对象是一个长度为n的向量$(x_1, \dots, x_n)$。并且每个元素都支持原子操作$UPDATE_p$和$SCAN_p$，其中p的取值范围为1到n

UPDATEp(v)将v的值赋给xp，不修改其他元素；SCANp()将当前的向量赋给p

假设有三个进程，其快照对象为 $(x_p, x_q, x_r) = (0, 0, 0)$，并且三个进程执行的代码如下。攻击者的目标是使得SCANp()返回的各元素之和最小

```
p: SCANp()
r: UPDATEr(2)  UPDATEr(0)
q: UPDATEq(6)  c = uniform-random(-1, 1)  UPDATEq(8*c)
```

对于弱攻击者而言，为了使元素之和最小，它应该让SCANp()在r和q的赋值前执行，或在r的赋值后，q的赋值前执行。因此和为0

对于强攻击者而言，为了使元素之和最小，它可以使q先执行到第二句，并且根据返回值判断下面的执行：

* 若c=1，则应让SCANp在第三句前执行，此时和为6
* 若c=-1，则应让SCANp在第三句后执行，此时和为-8



下面将上述的原子操作换成使用wait-free算法的操作

* 首先快照对象为一个寄存器数组A[1:n]
* 先定义一个操作collect，collect以一定的次序读取A
* SCAN：
  * 进程p重复地执行collect，直到两个连续的collect被成功执行（说明中间没有其他指令修改A）
  * 或p发现有另一个进程r在p执行SCAN的期间，至少执行了两次UPDATEr。这种情况下，p返回r的最后一次UPDATE的值
* UPDATE
  * 先执行一次SCAN

