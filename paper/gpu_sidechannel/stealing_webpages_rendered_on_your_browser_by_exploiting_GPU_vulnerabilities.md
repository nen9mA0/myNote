## II 与安全相关背景

### GPU内存模型

见GPU Basic Concept

### GPU执行指令过程

* GPU内存分配指令
* CPU到GPU数据传送指令
* 内核执行指令
* GPU到CPU数据传送指令
* GPU内存回收指令

### OpenGL和文字

OpenGL提供了一系列函数进行文字渲染

* glGenTextures()  生成一个文字对象
* glBindTexture()  加载一个文字对象
* glTextImage2D()  生成一个文字对象的图像数组
* glTexCoord()  绘制文字对象
* glDeleteTextures()  回收文字对象的内存

### 安全问题

#### 分配内存前不初始化

应用程序可以通过申请并访问新内存来获取之前的内存数据

#### 不可擦除内存

GPU不允许程序员直接擦除一些地方的内存，如常量内存，kernel代码，按值传递的参数。且很多情况下上述内存不会被GPU自动释放

#### 程序员管理的内存

一个kernel上的代码可以访问到同一个SP上其他kernel的local memory和private memory的信息

## III 系统与攻击模型

一个多用户系统上，受害软件占据了显示屏，攻击者使用一个低权限用户，但可以访问显卡

此外，我们考虑一个使用VirtualGL的远程GPU系统，受害程序可以使用VirtualGL而攻击者不行

## IV 泄露GPU内存

介绍两种获取敏感数据的方法，一种是在受害程序执行中获取，第二种是在执行后获取

### 基本攻击

首先执行一个简单的受害程序，它在NVIDIA GeForce GTX 780的3GB global memory上写入1GB的0x11111111，受害程序执行完后，执行一个简单的攻击程序读取global memory，此时由于显存没有被清零，因此有敏感数据被泄露。对于local memory和private memory也相同

### 进一步的攻击

![](pic\gpu_sidechannel_2_1.png)

正常的GPU执行流如图，解释如下

* CC Create Context
* AM Allocate Memory
* HD copy data CPU -> GPU
* EK Execute Kernel
* DH copy data GPU -> CPU
* FM Free Memory
* DC Delete Context

这里介绍了两种攻击，一个是End-of-Context，一个是End-of-Kernel

#### End-of-Context(EoC)

##### 攻击描述

GPU程序可以通过API显式释放Context（clReleaseContext()或cudaDeviceReset()），也可以是程序执行完毕后隐式释放。此时因为内存没有被清零，因此极有可能残留了渲染的图像、解密的密文或者kernel code等敏感数据

##### 攻击过程

###### 算法1 单目标程序

![](pic\gpu_sidechannel_2_2.png)

先死循环等待目标程序占据GPU运行，此后死循环检测目标程序何时停止占用GPU，一旦停止占用马上复制所有的显存

###### 算法2 多目标程序

![](pic\gpu_sidechannel_2_3.png)

当多个目标程序运行时不能单纯通过判断攻击程序占用显存与可用显存之和是否等于总显存量来确定目标程序释放context的时间。因此这里通过检测内存的释放来确定，即上一次可用内存小于当前可用内存。

但若每次遇到内存释放就传送一次显存的dump耗时太大，因此攻击程序在GPU上循环跑了一个kernel，kernel用于检测释放的内存是否存在GPU指令（如0x85800000001c3c02在NVIDIA Kepler中代表nop）。若检测到存在指令则将这块内存返回，此后将该块显存填0后释放，以防止下次检测再次传送相同的内存。

##### 减少内存分析量

因为一般的kernel只是用一部分显存，而每次传送的内存dump都等于总显存数，因此这里提出一种减少需要分析的显存量的方法。

方法：受害程序运行前先将global memory填充为一个固定值，当受害程序运行时只会改变其中一块内存，这样我们读回显存进行分析时就可以直接忽略那些仍为那个固定值的内存。

#### End-of-Kernel(EoK)

##### 攻击描述

通常情况下，GPU编程不提倡使用一个长期运行的kernel，因为GPU没有抢占式调度。因此大多数GPU程序会频繁地在GPU中调用一个或多个kernel。

而因为local memory和private memory访问较快，因此一些频繁访问的数据，如加密算法的S盒等一般放在这两种内存中

##### 攻击过程

![](pic\gpu_sidechannel_2_4.png)