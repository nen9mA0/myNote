### 主要算法

首先运行程序并打出trace

* 识别emulator使用的内存： abstract variable binding
* 识别emulator使用的内存中哪些可能存放着VPC(Virtual Program Counter)，使用的方法是基于这个变量对一段内存进行了访问，因为这段内存可能就存放着字节码
* 识别字节码的范围，通过上述识别VPC的方法确定的VPC，并通过判断其在解码循环中根据VPC访问的地址来划分范围
* 识别字节码的语义，首先获取bytecode的handler，如果handler中将VPC修改成与当前指令的下一个地址不连续的值就可能是个跳转指令。通过这样的识别可以构建CFG

#### Abstract variable binding

这个操作会找出所有通过某个变量作为地址来访问内容的操作。这基于以下常用的解码原理

```c
instruction = bytecode[VPC];
// or
instruction = *VPC;
```

VPC作为一个变量，被用于指定读取的内存，因此可以通过这种特性来判断VPC的位置。	

由于x86架构下，内存访问一般通过寄存器实现，即

```
VPC -> eax
memory[eax] -> instruction
```

在第一步，VPC只与eax绑定，第二步才把VPC与被读取的内存地址绑定起来

因此没法直接判断一个变量（假设它存在内存地址A）是否被用来访问其他地址（可能存放bytecode的地址），因为要通过一次寄存器的转储，而在转储过程中寄存器可能被改写，而改写可能是覆盖为一个完全无关的值（用来进行其他操作），也可能是对A存储的值的进一步运算。

##### 前向绑定（Forward Binding）

前向绑定可以分类出值作为地址用于内存读取的变量

```python
V = [ [0 for i in range(numof_reg)] ]	# V用于存放每个指令中每个寄存器的值
B = [ [0 for i in range(numof_reg)] ]	# B用于存放每个指令中每个寄存器的binding
FB = []
for i in range(1, numof_ins):
    B.append(copy.copy(B[0]))
    V.append(copy.copy(V[0]))			# 解析新指令前先将新指令的V和B初始化为上一次的值
    Update(V, B, i)					# 根据当前指令更新V和B
    if IsRegMemRead(ins[i]):			# 如果当前指令是IsMovRegMem(如mov r1, mem[r2])或IsComputeRegMem等指令
        FB.append(B[i][r2])			# 加入forward binding列表  
```

其中Update的规则为

```python
def Update(V, B, i):
    if IsMovConstant(ins[i]):		# 如果是mov r, c c为常数
        V[i][r] = c
    elif IsMovConstantMem(ins[i]):	# 如果是mov r, [c]
        B[i][r] = c					# 绑定为常量地址
        V[i][r] = mem[c]
    elif IsMovRegMem(ins[i]):		# 如果是mov r1, [r2]
        B[i][r1] = V[i-1][r2]		# r1绑定到r2表示的地址
        V[i][r1] = [r2]
    elif IsComputeConstant(ins[i]):	# 如果是r与c进行运算
        B[i][r] = B[i-1][r]				# 绑定与之前的不变
        V[i][r] = Compute( V[i-1][r], c )	# 值为计算后的值
    elif IsComputeConstantMem(ins[i]):	# 如果是r与[c]进行运算
        B[i][r] = B[i-1][r] , c			# 绑定为之前的绑定加上常量地址的组合
        V[i][r] = Compute( V[i-1][r], [c] )
    elif IsComputeRegMem(ins[i]):		# 如果是r1与[r2]进行运算
        B[i][r1] = B[i-1][r1] , V[i-1][r2]	# 绑定为之前r1的值和r2的值的集合
        V[i][r1] = Compute(V[i-1][r1], [r2])
```

前三个规则处理给reg赋新值的情况，在这种情况下寄存器绑定会被重置

后三个规则处理reg进行运算的情况，这种情况下寄存器绑定会在保持之前绑定的情况下加入新的绑定

绑定只有在当前寄存器与某个内存地址发生依赖时被修改

**问题**：如何处理两个寄存器进行运算的情况（似乎是包含在规则4-6里面）

##### 反向绑定（Backward Binding）

反向绑定跟踪内存写入时与之相关的各个变量（即对写入值或地址有影响的变量），因为在引用这些变量时必然存在对该变量的读取

```python
B = [ [0 for i in range(numof_reg)] for j in range(numof_ins) ]
	# V使用之前定义的V
for i in range(numof_ins-1, 1, -1):
    B[i] = B[i+1]		# 把状态初始化为之前的状态
    Update(V, B, i)
    if IsRegMemRead(ins[i]):
        BB.append(B[i][r2])
```

其中Update的规则为

```python
def Update(V, B, i):
    if IsWriteRegMem(ins[i]):	# 如果是 mov [r1], r2 类型的
        B[i][r2] = V[i][r1]		# 将r2绑定到r1的内存值
    elif IsWriteConstantMem(ins[i]):	# 如果是 mov [r], c
        B[i][r] = c
    elif IsMovRegReg(ins[i]):	# 如果是 mov r1, r2
        B[i][r2] = B[i+1][r1]	# 将r2与r1绑定
```

##### Dependent Abstract Variables

用于处理两个变量（内存位置）是绑定的情况，常见的情况是VPC是由一个记录基址的变量v1和一个记录偏移的变量v2决定的，因此VPC应该依赖于两个变量 v1 v2

做法是在forward binding里加入这样的规则：

首先定义DV，存放dependent variables

然后在Update里加入下面的规则

```python
elif IsWriteRegMem(ins[i]):		# 如果是mov [r1], r2
    DV[r1] = DV[r1], B[i][r2]	# 加入r2绑定的变量到DV中
```

在进行完forward binding后，对于DV中的所有元素`DV[i]`，建立一个反向的映射`DV[DV[i]] = i`

##### 变量生命期

因为上述绑定变量的方法中，记录绑定对象的方法是根据变量的地址，而一个地址可能被多个变量重复使用，因此应该弄清地址的生命期

这里只解决了stack上的对象生命期问题，方法是跟踪esp的值来判断变量是否被分配或回收。

#### 识别VPC

根据前向绑定和反向绑定的结果，可以确定那些被间接引用的内存地址，和通过某个变量间接写入的地址，若存在这样的内存地址访问方式，就是候选的VPC

#### 识别虚拟机行为

* 转换成CFG识别main loop

* 污点跟踪，识别fetch过程

  * 将上述操作中几个cluster识别出的VPC访问的内存部分作为假定的含有bytecode的内存
  * 将假定含有bytecode的内存染色，当有对于这段内存的读取时，判定该读取为VPC，并且染色对应的FB数组的依赖数据

* 识别dispatch过程，方法是识别那些有被染色数据参与运算目的地址的跳转语句

* 识别一连串的读取过程，因为cluster中的读取有如下几个可能

  * 读取新bytecode
  * 读取当前bytecode的操作数
  * 因为反向绑定算法不精确导致的与VPC无关的读取也被归类

  因此采用如下方法检测

  * 判断从上次的fetch操作后main loop是否进入了一次新的循环
  * 如果没有循环过，判断这个读取指令是否是用于取操作码（operand）的，如果存取的方式是当前的VPC加一个很小的偏移量，则判断为是用于取操作码的

#### 识别语义

* 一个bytecode的handler肯定被多次调用，从而可以认定这几个bytecode语义相近
* 修改VPC的指令可以视为跳转，其中如果有指令每次都将VPC修改为相同的值，可以视为无条件跳转