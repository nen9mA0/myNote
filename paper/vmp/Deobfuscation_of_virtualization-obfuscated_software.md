### 反混淆

#### 整体实现

* 打trace
* 在trace中识别system call和其参数（或dll等）
* 将所有与system call参数有关的控制流找出，包括含有条件跳转语句的控制流，并称其为relevant instructions
* 从这些relevant instruction中建立一个称为relevant subtrace的trace，这段trace就比较接近未混淆的代码

#### 基本思想

因为程序的交互最终都是与系统API直接相关的，因此这里的思想就是获取及跟踪程序中对API的调用与参数，根据调用的参数及顺序来确定程序功能

##### 依赖分析

为了对API参数进行跟踪，需要对数据和控制流依赖进行分析来对影响函数参数的语句进行归类划分

###### 数据依赖

函数参数的值可能是由多个语句进行计算的，所有直接影响该值的操作就是该值的数据依赖

###### 控制流依赖

因为在确定函数参数时，可能会有一些条件语句影响参数的值，这就被称为控制流依赖。

对于vmp来说，bytecode的解码过程直接影响到了调用函数时的参数，因此控制流依赖分析可能可以直接将整个虚拟机的dispatcher切分出来

##### 切片算法

本论文采取的方法是先使用数据依赖分析，再进行控制流依赖分析

###### ud-chains

`use-definition chains`即分析指令对一个变量的定义（赋值）及使用的过程，本论文的切片算法使用ud-chains进行数据依赖分析，但这里的数据依赖分析并不处理条件语句

**存在的问题**：

```
mov eax, [ecx+edx]
push eax
call print
```

对于这种情况参数的依赖是ecx和edx相加的地址，这是运行时决定的，这种情况下我们只能回溯这个地址被赋值时的地方，进行进一步的依赖分析

###### value-based dependence

为了解决上述问题提出的方法

这个方法重新定义了依赖的范围，假设op为影响参数值的操作的操作数，use(op)定义如下

* 若op是个寄存器r，则依赖列表为{r}
* 若op是个内存地址a，则依赖列表为{a}
* 否则为空{}

依赖计算方法：

* 初始化一个列表S，用于存放一个system call的参数对应的位置（可以是寄存器或内存地址）
* 从system call的位置向上回溯，如果指令I操作了列表中某个位置L，指令I就被标记为相关的指令，且L从S中移除，并加入use(op)的集合（这里的op是I中对应的op）
* 重复上述过程直到程序头或S列表为空

这种方法只专注于：当从一个地址读取值时，可以找出最近的一个修改该地址值的指令，而不注重该地址是怎么被计算出来的

**存在的问题**：

使用这种方法有个问题，当一个系统调用只接受结构体作为参数，在不知道结构体大小的情况下，这个方法无法追踪程序对结构体成员的修改

**解决方案**

维护一个集合P和M，P为参数的地址，M为通过相对地址引用访问的内存

* 初始的时候P保存调用函数时栈上的参数，M为空
* 正向扫描，若I的操作数访问了P中的元素，则引用该元素的地址处也有可能是用于访问P对应的内存地址的，因此加入P集合
* 如果一个内存访问指令是以P中元素为指针访问的，则将其加入M集合
* 如果一个指令写入了P中的元素，且不对原来的元素进行引用，那么将该元素从P中移除
* 重复直到system call或P为空

##### 相关条件控制流



