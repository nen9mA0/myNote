### 一般壳的特点

* 写后执行，即动态生成代码后执行生成的代码
* 不一定最后一层解密的代码就是目标程序的代码
* 往往有两种IAT表，一种是程序unpack的时候用的IAT，一种是真正原始程序用的IAT，两种IAT的内存空间一般不会重叠，因为unpack程序必须保证原始程序的IAT被完全重建且将控制权转移，而重建IAT表和其他工作往往需要调用一系列API，若unpacker覆盖了自己的IAT表将难以完成这项工作。这项特性可以被用于识别unpacker的边界。
  * 特性I：unpacker在跳转到OEP前会重建IAT
  * 特性II：如果一个API被从一个不是unpacker的IAT的地址被调用往往说明这是目标程序的IAT

### API调用处理

一般有两种方式调用WinAPI

* 隐式加载：写在IAT里，PE加载时自动加载对应库
* 显式加载：使用LoadLibrary和GetProcAddress加载

* 特殊情况I：硬编码API地址，但对于不同版本的Windows系统适配性差，且不能用于地址随机化的系统
* 特殊情况II：在运行时使用shellcode注入到受害进程中，通过SEH或PEB结构体获取kernel32.dll地址，但这种方式的适用范围不广

### API-HOOK

#### Hook绕过

##### 代码盗取

从被调用API的空间中复制一段代码到用户内存空间，调用API时先执行这部分被复制的代码，然后再跳转到被复制代码的下面部分执行，以绕过API函数开头的hook。

##### 子进程

创建一个子进程来执行unpack和恶意代码，因为用户层的IAT/EAT Hook只能监视其对应的进程。

##### Process Hollowing

将unpack和目标程序分成两个完全解耦的进程，可以绕过无法监视多进程的hook

##### 破坏hook模块

使用错误的参数调用API，若API没有被hook，windows默认SEH可以处理这些错误，因此目标程序可以正常执行。而对于hook的程序由于大多数没有开发相应的错误处理程序而将crash。

### DLL劫持

DLL劫持可以防止绕过，对于破坏hook模块，由于dll劫持后的代码一样可以将异常传给windows处理，对于代码盗取，dll劫持后执行代码盗取与执行一个用户函数没有区别

##### 问题

windows将核心dll的搜索路径定为绝对路径并写入注册表

##### 解决方法

