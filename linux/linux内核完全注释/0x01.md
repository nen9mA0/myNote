# 0x01 内核初始化过程
## main.c
110-113行 取之前从bios中读出的信息
* 根目录设备号：地址0x901FC处
* 磁盘信息： 地址0x90080处
* 扩展内存大小：地址0x90002处

**（这里有个地方我不是很清楚，为什么内存大小的计算是这样的）**
```
memory_end = (1<<20) + (EXT_MEM_K<<10);
memory_end &= 0xfffff000;
//第一行的EXT_MEM_K存储的是外存的KB数，所以要左移10位（乘1024），第二行用于4KB对齐
//但是为什么第一行要加个1MB，是因为原本的机器内存默认都是1MB么
```
114-122行 
* 如果内存大于16MB则视为16M
* 如果内存大于12M则把前4MB设为缓冲区
* 如果内存大于6M小于12M则把前2MB设为缓冲区
* 如果内存小于6M则把前1MB设为缓冲区

123-125行 如果定义了RAMDISK则调用**rd_init**初始化虚拟盘，并将前RAMDISK*1024字节内存划为虚拟盘
125-135行 调用初始化程序
* mem_init 内存
* trap_init 陷阱门
* blk_dev_init 

### 调用
#### RAMDISK初始化：kernel/blk_drv/ramdisk.c/rd_init()
**ramdisk.c的内容在0x03 块设备驱动程序详细说**
这里填充了一个叫 blk_dev_struct的数据结构，定义在kernel/blk_drv/blk.h 第45行，如下
```C
struct blk_dev_struct {
	void (*request_fn)(void);
	struct request * current_request;
};

```
填充的数组**blk_dev**是blk_dev_struct类型的，定义在ll_rw_blk.c，用于存储块设备的参数，这部分内容之后章节会提到
```C
/* blk_dev_struct is:
 *	do_request-address
 *	next-request
 */
struct blk_dev_struct blk_dev[NR_BLK_DEV] = {
	{ NULL, NULL },		/* no_dev */
	{ NULL, NULL },		/* dev mem */
	{ NULL, NULL },		/* dev fd */
	{ NULL, NULL },		/* dev hd */
	{ NULL, NULL },		/* dev ttyx */
	{ NULL, NULL },		/* dev tty */
	{ NULL, NULL }		/* dev lp */
};
```
看注释即可知道blk_dev数组第二项为内存的描述符，其**request_fn**函数用于处理对该设备的调用
rd_init()将blk_dev[1].request_fn初始化为ramdisk的处理函数**do_rd_request**
并且对ramdisk范围的空间进行初始化（写0）
#### 内存初始化：mm/memory.c/mem_init()
**memory.c的内容在0x07 内存管理详细说**
在memory.c中声明了一个数组mem_map用于标记页表的使用状况


* mem_init将映射0-1MB的内存页表初始化为USED（0x64,即100）
* 剩余有内存映射的页表项初始化为0
* 对于超出内存大小的映射（如总内存只有12MB，但页表可以映射16MB内存），初始化为USED

#### 陷阱门初始化 kernel/traps.c/trap_init()
**traps.c在0x02 进程调度与系统调用会详细讲**
这里需要详细说明下IDT（中断向量表）中的几类不同中断
[upl-image-preview url=//bbs.xdsec.org/assets/files/2019-01-28/1548708094-597623-0-12833186831ecn.png]
上文已经有过这张图
